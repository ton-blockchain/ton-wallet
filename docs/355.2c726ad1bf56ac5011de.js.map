{"version":3,"file":"355.2c726ad1bf56ac5011de.js","mappings":"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","sources":["webpack://mytonwallet/./src/api/chains/ton/util/dns.ts","webpack://mytonwallet/./src/util/fetch.ts","webpack://mytonwallet/./src/api/chains/ton/util/tonCore.ts","webpack://mytonwallet/./src/api/environment.ts","webpack://mytonwallet/./src/api/common/utils.ts","webpack://mytonwallet/./src/util/compareVersions.ts","webpack://mytonwallet/./src/util/ledger/index.ts"],"sourcesContent":["/* Source https://github.com/toncenter/tonweb/blob/master/src/contract/dns/DnsUtils.js */\nimport type { Cell, Slice } from '@ton/core';\nimport { Address, Builder } from '@ton/core';\n\nimport type { TonClient } from './TonClient';\n\nimport { DnsCategory } from '../constants';\nimport { sha256BigInt } from './other';\n\nexport type DnsResult = Cell | Address | string | undefined;\n\nexport function dnsCategoryToBigInt(category?: string) {\n  if (!category) return 0n; // all categories\n  return sha256BigInt(category);\n}\n\nfunction parseSmartContractAddressImpl(cell: Cell, prefix0: number, prefix1: number): Address | undefined {\n  const slice = cell.asSlice();\n\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n\n  if (byte0 !== prefix0 || byte1 !== prefix1) {\n    throw new Error('Invalid dns record value prefix');\n  }\n\n  return parseAddress(slice);\n}\n\nfunction parseSmartContractAddressRecord(cell: Cell): Address | undefined {\n  return parseSmartContractAddressImpl(cell, 0x9f, 0xd3);\n}\n\nfunction parseNextResolverRecord(cell: Cell): Address | undefined {\n  return parseSmartContractAddressImpl(cell, 0xba, 0x93);\n}\n\nfunction parseStorageBagIdRecord(cell: Cell): string {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n\n  if (byte0 !== 0x74 || byte1 !== 0x73) {\n    throw new Error('Invalid dns record value prefix');\n  }\n\n  const buffer = slice.loadBuffer(4);\n  return buffer.toString('hex');\n}\n\nfunction parseSiteRecord(cell: Cell): string {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n\n  if (byte0 === 0xad || byte1 === 0x01) {\n    return parseAdnlAddressRecord(cell);\n  } else {\n    return parseStorageBagIdRecord(cell);\n  }\n}\n\nfunction parseAdnlAddressRecord(cell: Cell): string {\n  const slice = cell.asSlice();\n  const byte0 = slice.loadUint(8);\n  const byte1 = slice.loadUint(8);\n\n  if (byte0 !== 0xad || byte1 !== 0x01) {\n    throw new Error('Invalid dns record value prefix');\n  }\n\n  const buffer = slice.loadBuffer(4);\n  return buffer.toString('hex');\n}\n\nasync function dnsResolveImpl(\n  client: TonClient,\n  dnsAddress: string,\n  rawDomainBytes: Buffer,\n  category?: DnsCategory,\n  oneStep?: boolean,\n): Promise<DnsResult> {\n  const len = rawDomainBytes.length * 8;\n\n  const domainCell = new Builder()\n    .storeBuffer(rawDomainBytes)\n    .asCell();\n\n  const categoryBigInt = dnsCategoryToBigInt(category);\n  const { stack } = await client.callGetMethod(Address.parse(dnsAddress), 'dnsresolve', [\n    { type: 'slice', cell: domainCell },\n    { type: 'int', value: categoryBigInt },\n  ]);\n\n  const resultLen = stack.readNumber();\n\n  let cell: Cell | undefined;\n\n  try {\n    cell = stack.readCell();\n  } catch (err) {\n    // Do nothing\n  }\n\n  if (resultLen === 0) {\n    return undefined; // domain cannot be resolved\n  }\n\n  if (resultLen % 8 !== 0) {\n    throw new Error('domain split not at a component boundary');\n  }\n  // if (rawDomainBytes[resultLen] !== 0) {\n  //     throw new Error('domain split not at a component boundary');\n  // }\n  if (resultLen > len) {\n    throw new Error(`invalid response ${resultLen}/${len}`);\n  } else if (resultLen === len) {\n    if (category === DnsCategory.DnsNextResolver) {\n      return cell ? parseNextResolverRecord(cell) : undefined;\n    } else if (category === DnsCategory.Wallet) {\n      return cell ? parseSmartContractAddressRecord(cell) : undefined;\n    } else if (category === DnsCategory.Site) {\n      return cell ? parseSiteRecord(cell) : undefined;\n    } else if (category === DnsCategory.BagId) {\n      return cell ? parseStorageBagIdRecord(cell) : undefined;\n    } else {\n      return cell;\n    }\n  } else if (!cell) {\n    return undefined; // domain cannot be resolved\n  } else {\n    const nextAddress = parseNextResolverRecord(cell)!;\n    if (oneStep) {\n      if (category === DnsCategory.DnsNextResolver) {\n        return nextAddress;\n      } else {\n        return undefined;\n      }\n    } else {\n      return dnsResolveImpl(client, nextAddress.toString(), rawDomainBytes.slice(resultLen / 8), category, false);\n    }\n  }\n}\n\n/** Encodes the domain in accordance with the TEP-81 standard */\nexport function encodeDomain(domain: string): string {\n  if (!domain || !domain.length) {\n    throw new Error('empty domain');\n  }\n  if (domain === '.') {\n    return '';\n  }\n\n  domain = domain.toLowerCase();\n\n  for (let i = 0; i < domain.length; i++) {\n    if (domain.charCodeAt(i) <= 32) {\n      throw new Error('bytes in range 0..32 are not allowed in domain names');\n    }\n  }\n\n  for (let i = 0; i < domain.length; i++) {\n    const s = domain.substring(i, i + 1);\n    for (let c = 127; c <= 159; c++) { // another control codes range\n      if (s === String.fromCharCode(c)) {\n        throw new Error('bytes in range 127..159 are not allowed in domain names');\n      }\n    }\n  }\n\n  const arr = domain.split('.');\n\n  arr.forEach((part) => {\n    if (!part.length) {\n      throw new Error('domain name cannot have an empty component');\n    }\n  });\n\n  return `${arr.reverse().join('\\0')}\\0`;\n}\n\nexport function dnsResolve(\n  client: TonClient,\n  rootDnsAddress: string,\n  domain: string,\n  category?: DnsCategory,\n  oneStep?: boolean,\n): Promise<DnsResult> {\n  let rawDomain = encodeDomain(domain);\n  if (rawDomain.length < 126) {\n    rawDomain = `\\0${rawDomain}`;\n  }\n\n  return dnsResolveImpl(client, rootDnsAddress, Buffer.from(rawDomain), category, oneStep);\n}\n\nfunction parseAddress(slice: Slice): Address | undefined {\n  slice.loadUint(3);\n  let n = slice.loadUintBig(8);\n  if (n > 127n) { // Maybe it's not necessary?\n    n -= 256n;\n  }\n\n  const hashPart = slice.loadUintBig(256);\n  if (`${n.toString(10)}:${hashPart.toString(16)}` === '0:0') {\n    return undefined;\n  }\n  const s = `${n.toString(10)}:${hashPart.toString(16).padStart(64, '0')}`;\n  return Address.parse(s);\n}\n","import {\n  DEFAULT_ERROR_PAUSE,\n  DEFAULT_RETRIES,\n  DEFAULT_TIMEOUT,\n  IPFS_GATEWAY_BASE_URL,\n  PROXY_API_BASE_URL,\n} from '../config';\nimport { ApiServerError } from '../api/errors';\nimport { logDebug } from './logs';\nimport { pause } from './schedulers';\n\ntype QueryParams = Record<string, string | number | boolean | string[]>;\n\nconst MAX_TIMEOUT = 30000; // 30 sec\n\nexport function fetchJsonWithProxy(url: string | URL, data?: QueryParams, init?: RequestInit) {\n  return fetchJson(getProxiedJsonUrl(url.toString()), data, init);\n}\n\nexport async function fetchJson(url: string | URL, data?: QueryParams, init?: RequestInit) {\n  const urlObject = new URL(url);\n  if (data) {\n    Object.entries(data).forEach(([key, value]) => {\n      if (value === undefined) {\n        return;\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach((item) => {\n          urlObject.searchParams.append(key, item.toString());\n        });\n      } else {\n        urlObject.searchParams.set(key, value.toString());\n      }\n    });\n  }\n\n  const response = await fetchWithRetry(urlObject, init);\n\n  return response.json();\n}\n\nexport async function fetchWithRetry(url: string | URL, init?: RequestInit, options?: {\n  retries?: number;\n  timeouts?: number | number[];\n  shouldSkipRetryFn?: (message?: string, statusCode?: number) => boolean;\n}) {\n  const {\n    retries = DEFAULT_RETRIES,\n    timeouts = DEFAULT_TIMEOUT,\n    shouldSkipRetryFn = isNotTemporaryError,\n  } = options ?? {};\n\n  let message = 'Unknown error.';\n  let statusCode: number | undefined;\n\n  for (let i = 1; i <= retries; i++) {\n    try {\n      if (i > 1) {\n        logDebug(`Retry request #${i}:`, url.toString(), statusCode);\n      }\n\n      const timeout = Array.isArray(timeouts)\n        ? timeouts[i - 1] ?? timeouts[timeouts.length - 1]\n        : Math.min(timeouts * i, MAX_TIMEOUT);\n      const response = await fetchWithTimeout(url, init, timeout);\n      statusCode = response.status;\n\n      if (statusCode >= 400) {\n        const { error } = await response.json().catch(() => {});\n        throw new Error(error ?? `HTTP Error ${statusCode}`);\n      }\n\n      return response;\n    } catch (err: any) {\n      message = typeof err === 'string' ? err : err.message ?? message;\n\n      const shouldSkipRetry = shouldSkipRetryFn(message, statusCode);\n\n      if (shouldSkipRetry) {\n        throw new ApiServerError(message, statusCode);\n      }\n\n      if (i < retries) {\n        await pause(DEFAULT_ERROR_PAUSE * i);\n      }\n    }\n  }\n\n  throw new ApiServerError(message);\n}\n\nexport async function fetchWithTimeout(url: string | URL, init?: RequestInit, timeout = DEFAULT_TIMEOUT) {\n  const controller = new AbortController();\n  const id = setTimeout(() => {\n    controller.abort();\n  }, timeout);\n\n  try {\n    return await fetch(url, {\n      ...init,\n      signal: controller.signal,\n    });\n  } finally {\n    clearTimeout(id);\n  }\n}\n\nexport async function handleFetchErrors(response: Response, ignoreHttpCodes?: number[]) {\n  if (!response.ok && (!ignoreHttpCodes?.includes(response.status))) {\n    // eslint-disable-next-line prefer-const\n    let { error, errors } = await response.json().catch(() => undefined);\n    if (!error && errors && errors.length) {\n      error = errors[0]?.msg;\n    }\n\n    throw new ApiServerError(error ?? `HTTP Error ${response.status}`, response.status);\n  }\n  return response;\n}\n\nfunction isNotTemporaryError(message?: string, statusCode?: number) {\n  return statusCode && [400, 404].includes(statusCode);\n}\n\nexport function getProxiedJsonUrl(url: string) {\n  return `${PROXY_API_BASE_URL}/download-json?url=${encodeURIComponent(url)}`;\n}\n\nexport function getProxiedLottieUrl(url: string) {\n  return `${PROXY_API_BASE_URL}/download-lottie?url=${encodeURIComponent(url)}`;\n}\n\nexport function fixIpfsUrl(url: string) {\n  return url.replace('ipfs://', IPFS_GATEWAY_BASE_URL);\n}\n","import type { OpenedContract } from '@ton/core';\nimport {\n  Address, beginCell, Builder, Cell, Dictionary,\n} from '@ton/core';\nimport { WalletContractV1R1 } from '@ton/ton/dist/wallets/WalletContractV1R1';\nimport { WalletContractV1R2 } from '@ton/ton/dist/wallets/WalletContractV1R2';\nimport { WalletContractV1R3 } from '@ton/ton/dist/wallets/WalletContractV1R3';\nimport { WalletContractV2R1 } from '@ton/ton/dist/wallets/WalletContractV2R1';\nimport { WalletContractV2R2 } from '@ton/ton/dist/wallets/WalletContractV2R2';\nimport { WalletContractV3R1 } from '@ton/ton/dist/wallets/WalletContractV3R1';\nimport { WalletContractV3R2 } from '@ton/ton/dist/wallets/WalletContractV3R2';\nimport { WalletContractV4 } from '@ton/ton/dist/wallets/WalletContractV4';\nimport { WalletContractV5R1 } from '@ton/ton/dist/wallets/WalletContractV5R1';\n\nimport type { ApiNetwork } from '../../../types';\nimport type { ApiTonWalletVersion, TokenTransferBodyParams } from '../types';\n\nimport { DEFAULT_TIMEOUT, TONCENTER_MAINNET_URL, TONCENTER_TESTNET_URL } from '../../../../config';\nimport { getDnsZoneByCollection } from '../../../../util/dns';\nimport { fromKeyValueArrays, mapValues } from '../../../../util/iteratees';\nimport { logDebugError } from '../../../../util/logs';\nimport withCacheAsync from '../../../../util/withCacheAsync';\nimport { DnsItem } from '../contracts/DnsItem';\nimport { JettonMinter } from '../contracts/JettonMaster';\nimport { JettonStakingOpCodes } from '../contracts/JettonStaking/imports/constants';\nimport { StakeWallet } from '../contracts/JettonStaking/StakeWallet';\nimport { StakingPool } from '../contracts/JettonStaking/StakingPool';\nimport { JettonWallet } from '../contracts/JettonWallet';\nimport { hexToBytes } from '../../../common/utils';\nimport { getEnvironment } from '../../../environment';\nimport { DEFAULT_IS_BOUNCEABLE, JettonOpCode, LiquidStakingOpCode, OpCode } from '../constants';\nimport { generateQueryId } from './index';\n\nimport { TonClient } from './TonClient';\n\ntype TonWalletType = typeof WalletContractV1R1\n  | typeof WalletContractV1R2\n  | typeof WalletContractV1R3\n  | typeof WalletContractV2R1\n  | typeof WalletContractV2R2\n  | typeof WalletContractV3R1\n  | typeof WalletContractV3R2\n  | typeof WalletContractV4\n  | typeof WalletContractV5R1;\n\nexport type TonWallet = WalletContractV1R1\n  | WalletContractV1R2\n  | WalletContractV1R3\n  | WalletContractV2R1\n  | WalletContractV2R2\n  | WalletContractV3R1\n  | WalletContractV3R2\n  | WalletContractV4\n  | WalletContractV5R1;\n\nconst TON_MAX_COMMENT_BYTES = 127;\n\nlet clientByNetwork: Record<ApiNetwork, TonClient> | undefined;\n\nexport const walletClassMap: Record<ApiTonWalletVersion, TonWalletType> = {\n  simpleR1: WalletContractV1R1,\n  simpleR2: WalletContractV1R2,\n  simpleR3: WalletContractV1R3,\n  v2R1: WalletContractV2R1,\n  v2R2: WalletContractV2R2,\n  v3R1: WalletContractV3R1,\n  v3R2: WalletContractV3R2,\n  v4R2: WalletContractV4,\n  W5: WalletContractV5R1,\n};\n\nexport function getTonClient(network: ApiNetwork = 'mainnet') {\n  if (!clientByNetwork) {\n    const { apiHeaders, toncenterMainnetKey, toncenterTestnetKey } = getEnvironment();\n\n    clientByNetwork = {\n      mainnet: new TonClient({\n        endpoint: `${TONCENTER_MAINNET_URL}/api/v2/jsonRPC`,\n        timeout: DEFAULT_TIMEOUT,\n        apiKey: toncenterMainnetKey,\n        headers: apiHeaders,\n      }),\n      testnet: new TonClient({\n        endpoint: `${TONCENTER_TESTNET_URL}/api/v2/jsonRPC`,\n        timeout: DEFAULT_TIMEOUT,\n        apiKey: toncenterTestnetKey,\n        headers: apiHeaders,\n      }),\n    };\n  }\n\n  return clientByNetwork[network];\n}\n\nexport const resolveTokenWalletAddress = withCacheAsync(\n  async (network: ApiNetwork, address: string, tokenAddress: string) => {\n    const minter = getTonClient(network).open(new JettonMinter(Address.parse(tokenAddress)));\n    const walletAddress = await minter.getWalletAddress(Address.parse(address));\n    return toBase64Address(walletAddress, true, network);\n  },\n);\n\nexport const resolveTokenAddress = withCacheAsync(async (network: ApiNetwork, tokenWalletAddress: string) => {\n  const tokenWallet = getTonClient(network).open(new JettonWallet(Address.parse(tokenWalletAddress)));\n  const data = await tokenWallet.getWalletData();\n  return toBase64Address(data.minter, true, network);\n});\n\nexport const getWalletPublicKey = withCacheAsync(async (network: ApiNetwork, address: string) => {\n  const res = await getTonClient(network).runMethodWithError(Address.parse(address), 'get_public_key');\n  if (res.exit_code !== 0) {\n    return undefined;\n  }\n\n  const bigintKey = res.stack.readBigNumber();\n  const hex = bigintKey.toString(16).padStart(64, '0');\n  return hexToBytes(hex);\n});\n\nexport const getJettonPoolStakeWallet = withCacheAsync(async (\n  network: ApiNetwork,\n  poolAddress: string,\n  period: number,\n  address: string,\n): Promise<OpenedContract<StakeWallet>> => {\n  const tonClient = getTonClient(network);\n  const pool = tonClient.open(StakingPool.createFromAddress(Address.parse(poolAddress)));\n  const walletAddress = (await pool.getWalletAddress(Address.parse(address), period))!;\n  return tonClient.open(StakeWallet.createFromAddress(walletAddress));\n});\n\nexport function getJettonMinterData(network: ApiNetwork, address: string) {\n  const contract = getTonClient(network).open(new JettonMinter(Address.parse(address)));\n  return contract.getJettonData();\n}\n\nexport function oneCellFromBoc(bytes: Uint8Array) {\n  return Cell.fromBoc(Buffer.from(bytes));\n}\n\nexport function toBase64Address(address: Address | string, isBounceable = DEFAULT_IS_BOUNCEABLE, network?: ApiNetwork) {\n  if (typeof address === 'string') {\n    address = Address.parse(address);\n  }\n  return address.toString({\n    urlSafe: true,\n    bounceable: isBounceable,\n    testOnly: network === 'testnet',\n  });\n}\n\nexport function toRawAddress(address: Address | string) {\n  if (typeof address === 'string') {\n    address = Address.parse(address);\n  }\n  return address.toRawString();\n}\n\nexport function buildTokenTransferBody(params: TokenTransferBodyParams) {\n  const {\n    queryId,\n    tokenAmount,\n    toAddress,\n    responseAddress,\n    forwardAmount,\n    customPayload,\n  } = params;\n  let forwardPayload = params.forwardPayload;\n\n  let builder = new Builder()\n    .storeUint(JettonOpCode.Transfer, 32)\n    .storeUint(queryId || generateQueryId(), 64)\n    .storeCoins(tokenAmount)\n    .storeAddress(Address.parse(toAddress))\n    .storeAddress(Address.parse(responseAddress))\n    .storeMaybeRef(customPayload)\n    .storeCoins(forwardAmount ?? 0n);\n\n  if (forwardPayload instanceof Uint8Array) {\n    const freeBytes = Math.round(builder.availableBits / 8);\n    forwardPayload = packBytesAsSnake(forwardPayload, freeBytes);\n  }\n\n  if (!forwardPayload) {\n    builder.storeBit(false);\n  } else if (typeof forwardPayload === 'string') {\n    builder = builder.storeBit(false)\n      .storeUint(0, 32)\n      .storeBuffer(Buffer.from(forwardPayload));\n  } else if (forwardPayload instanceof Uint8Array) {\n    builder = builder.storeBit(false)\n      .storeBuffer(Buffer.from(forwardPayload));\n  } else {\n    builder = builder.storeBit(true)\n      .storeRef(forwardPayload);\n  }\n\n  return builder.endCell();\n}\n\nexport function parseBase64(base64: string) {\n  try {\n    return Cell.fromBase64(base64);\n  } catch (err) {\n    logDebugError('parseBase64', err);\n    return Uint8Array.from(Buffer.from(base64, 'base64'));\n  }\n}\n\nexport function commentToBytes(comment: string): Uint8Array {\n  const buffer = Buffer.from(comment);\n  const bytes = new Uint8Array(buffer.length + 4);\n\n  const startBuffer = Buffer.alloc(4);\n  startBuffer.writeUInt32BE(OpCode.Comment);\n  bytes.set(startBuffer, 0);\n  bytes.set(buffer, 4);\n\n  return bytes;\n}\n\nexport function packBytesAsSnake(bytes: Uint8Array, maxBytes = TON_MAX_COMMENT_BYTES): Uint8Array | Cell {\n  const buffer = Buffer.from(bytes);\n  if (buffer.length <= maxBytes) {\n    return bytes;\n  }\n\n  return packBytesAsSnakeCell(bytes);\n}\n\nexport function packBytesAsSnakeCell(bytes: Uint8Array): Cell {\n  const bytesPerCell = TON_MAX_COMMENT_BYTES;\n  const cellCount = Math.ceil(bytes.length / bytesPerCell);\n  let headCell: Cell | undefined;\n\n  for (let i = cellCount - 1; i >= 0; i--) {\n    const cellOffset = i * bytesPerCell;\n    const cellLength = Math.min(bytesPerCell, bytes.length - cellOffset);\n    const cellBuffer = Buffer.from(bytes.buffer, bytes.byteOffset + cellOffset, cellLength); // This creates a buffer that references the input bytes instead of copying them\n\n    const nextHeadCell = new Builder().storeBuffer(cellBuffer);\n    if (headCell) {\n      nextHeadCell.storeRef(headCell);\n    }\n    headCell = nextHeadCell.endCell();\n  }\n\n  return headCell ?? Cell.EMPTY;\n}\n\nexport function packBytesAsSnakeForEncryptedData(data: Uint8Array): Uint8Array | Cell {\n  const ROOT_BUILDER_BYTES = 39;\n  const MAX_CELLS_AMOUNT = 16;\n\n  if (data.length > ROOT_BUILDER_BYTES + MAX_CELLS_AMOUNT * TON_MAX_COMMENT_BYTES) {\n    throw new Error('Input text is too long');\n  }\n\n  return new Builder()\n    .storeBuffer(Buffer.from(data.subarray(0, ROOT_BUILDER_BYTES)))\n    .storeRef(packBytesAsSnakeCell(data.subarray(ROOT_BUILDER_BYTES)))\n    .endCell();\n}\n\nexport function buildLiquidStakingDepositBody(queryId?: number) {\n  return new Builder()\n    .storeUint(LiquidStakingOpCode.Deposit, 32)\n    .storeUint(queryId || 0, 64)\n    .asCell();\n}\n\nexport function buildLiquidStakingWithdrawBody(options: {\n  queryId?: number;\n  amount: bigint;\n  responseAddress: string;\n  waitTillRoundEnd?: boolean; // opposite of request_immediate_withdrawal\n  fillOrKill?: boolean;\n}) {\n  const {\n    queryId, amount, responseAddress, waitTillRoundEnd, fillOrKill,\n  } = options;\n\n  const customPayload = buildLiquidStakingWithdrawCustomPayload(waitTillRoundEnd, fillOrKill);\n\n  return new Builder()\n    .storeUint(JettonOpCode.Burn, 32)\n    .storeUint(queryId ?? 0, 64)\n    .storeCoins(amount)\n    .storeAddress(Address.parse(responseAddress))\n    .storeBit(1)\n    .storeRef(customPayload)\n    .asCell();\n}\n\nexport function buildLiquidStakingWithdrawCustomPayload(waitTillRoundEnd?: boolean, fillOrKill?: boolean) {\n  return new Builder()\n    .storeUint(Number(waitTillRoundEnd), 1)\n    .storeUint(Number(fillOrKill), 1)\n    .asCell();\n}\n\nexport function getTokenBalance(network: ApiNetwork, walletAddress: string) {\n  const tokenWallet = getTonClient(network).open(new JettonWallet(Address.parse(walletAddress)));\n  return tokenWallet.getJettonBalance();\n}\n\nexport function parseAddress(address: string): {\n  isValid: boolean;\n  isRaw?: boolean;\n  isUserFriendly?: boolean;\n  isBounceable?: boolean;\n  isTestOnly?: boolean;\n  address?: Address;\n} {\n  try {\n    if (Address.isRaw(address)) {\n      return {\n        address: Address.parseRaw(address),\n        isRaw: true,\n        isValid: true,\n      };\n    } else if (Address.isFriendly(address)) {\n      return {\n        ...Address.parseFriendly(address),\n        isUserFriendly: true,\n        isValid: true,\n      };\n    }\n  } catch (err) {\n    // Do nothing\n  }\n\n  return { isValid: false };\n}\n\nexport function getIsRawAddress(address: string) {\n  return Boolean(parseAddress(address).isRaw);\n}\n\nexport async function getDnsItemDomain(network: ApiNetwork, address: Address | string) {\n  if (typeof address === 'string') address = Address.parse(address);\n\n  const contract = getTonClient(network)\n    .open(new DnsItem(address));\n  const nftData = await contract.getNftData();\n  const collectionAddress = toBase64Address(nftData.collectionAddress, true);\n\n  const zone = getDnsZoneByCollection(collectionAddress);\n\n  const base = zone?.isTelemint\n    ? await contract.getTelemintDomain()\n    : await contract.getDomain();\n\n  return `${base}.${zone?.suffixes[0]}`;\n}\n\nexport function buildJettonUnstakePayload(jettonsToUnstake: bigint, forceUnstake?: boolean, queryId?: bigint) {\n  return beginCell()\n    .storeUint(JettonStakingOpCodes.UNSTAKE_JETTONS, 32)\n    .storeUint(queryId ?? 0, 64)\n    .storeCoins(jettonsToUnstake)\n    .storeBit(forceUnstake ?? false)\n    .endCell();\n}\n\nexport function buildJettonClaimPayload(poolWallets: string[], queryId?: bigint) {\n  const rewardsToClaim = Dictionary.empty(Dictionary.Keys.Address(), Dictionary.Values.Bool());\n\n  for (const poolWallet of poolWallets) {\n    rewardsToClaim.set(Address.parse(poolWallet), true);\n  }\n\n  return beginCell()\n    .storeUint(JettonStakingOpCodes.CLAIM_REWARDS, 32)\n    .storeUint(queryId ?? 0, 64)\n    .storeDict(rewardsToClaim, Dictionary.Keys.Address(), Dictionary.Values.Bool())\n    .endCell();\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function unpackDicts(obj: Record<string, any | Dictionary<any, any>>): AnyLiteral {\n  if (!isSimpleObject(obj)) {\n    return obj;\n  }\n\n  return mapValues(obj, (value) => {\n    if (value instanceof Dictionary) {\n      return unpackDicts(fromKeyValueArrays(value.keys(), value.values()));\n    }\n    if (isSimpleObject(value)) {\n      return unpackDicts(value);\n    }\n    return value;\n  });\n}\n\nfunction isSimpleObject(obj: any) {\n  // eslint-disable-next-line no-null/no-null\n  return obj !== null\n    && typeof obj === 'object'\n    && Object.getPrototypeOf(obj) === Object.prototype;\n}\n\nexport function getOurFeePayload() {\n  return new Builder()\n    .storeUint(OpCode.OurFee, 32)\n    .endCell();\n}\n","/*\n * This module is to be used instead of /src/util/environment.ts\n * when `window` is not available (e.g. in a web worker).\n */\nimport type { ApiInitArgs } from './types';\n\nimport {\n  ELECTRON_TONCENTER_MAINNET_KEY,\n  ELECTRON_TONCENTER_TESTNET_KEY,\n  IS_CAPACITOR,\n  TONCENTER_MAINNET_KEY,\n  TONCENTER_TESTNET_KEY,\n} from '../config';\n\nconst ELECTRON_ORIGIN = 'file://';\n\nlet environment: ApiInitArgs & {\n  isDappSupported?: boolean;\n  isSseSupported?: boolean;\n  apiHeaders?: AnyLiteral;\n  toncenterMainnetKey?: string;\n  toncenterTestnetKey?: string;\n};\n\nexport function setEnvironment(args: ApiInitArgs) {\n  environment = {\n    ...args,\n    isDappSupported: true,\n    isSseSupported: args.isElectron || (IS_CAPACITOR && !args.isNativeBottomSheet),\n\n    apiHeaders: { 'X-App-Origin': args.isElectron ? ELECTRON_ORIGIN : self?.origin },\n    toncenterMainnetKey: args.isElectron ? ELECTRON_TONCENTER_MAINNET_KEY : TONCENTER_MAINNET_KEY,\n    toncenterTestnetKey: args.isElectron ? ELECTRON_TONCENTER_TESTNET_KEY : TONCENTER_TESTNET_KEY,\n  };\n  return environment;\n}\n\nexport function getEnvironment() {\n  return environment;\n}\n","import { STAKING_POOLS } from '../../config';\n\nexport function sha256(bytes: Uint8Array) {\n  return crypto.subtle.digest('SHA-256', bytes);\n}\n\nexport function bytesToHex(bytes: Uint8Array) {\n  return Buffer.from(bytes).toString('hex');\n}\n\nexport function hexToBytes(hex: string) {\n  return Uint8Array.from(Buffer.from(hex, 'hex'));\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  return Buffer.from(bytes).toString('base64');\n}\n\nexport function base64ToBytes(base64: string) {\n  return Uint8Array.from(Buffer.from(base64, 'base64'));\n}\n\nexport function base64ToString(base64: string) {\n  return Buffer.from(base64, 'base64').toString('utf-8');\n}\n\nexport function isKnownStakingPool(address: string) {\n  return STAKING_POOLS.some((poolPart) => address.endsWith(poolPart));\n}\n","export default function compareVersions(versionA: string, versionB: string): -1 | 0 | 1 {\n  const partsA = versionA.split('.').map(Number);\n  const partsB = versionB.split('.').map(Number);\n\n  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\n    const partA = partsA[i] || 0;\n    const partB = partsB[i] || 0;\n\n    if (partA > partB) return 1;\n    if (partA < partB) return -1;\n  }\n\n  return 0;\n}\n","import { StatusCodes } from '@ledgerhq/errors';\nimport TransportWebHID from '@ledgerhq/hw-transport-webhid';\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport type { HIDTransport } from '@mytonwallet/capacitor-usb-hid';\nimport type { StateInit } from '@ton/core';\nimport { loadStateInit } from '@ton/core';\nimport type { TonPayloadFormat } from '@ton-community/ton-ledger';\nimport { KNOWN_JETTONS, parseMessage, TonTransport } from '@ton-community/ton-ledger';\nimport type { ICapacitorUSBDevice } from '@mytonwallet/capacitor-usb-hid/dist/esm/definitions';\nimport { Address } from '@ton/core/dist/address/Address';\nimport { Builder } from '@ton/core/dist/boc/Builder';\nimport { Cell } from '@ton/core/dist/boc/Cell';\nimport { SendMode } from '@ton/core/dist/types/SendMode';\n\nimport type { ApiSubmitTransferOptions } from '../../api/methods/types';\nimport type { ApiTonConnectProof } from '../../api/tonConnect/types';\nimport type {\n  ApiEthenaStakingState,\n  ApiJettonStakingState,\n  ApiLocalTransactionParams,\n  ApiNetwork,\n  ApiNft,\n  ApiSignedTransfer,\n  ApiStakingState,\n  ApiTransferToSign,\n} from '../../api/types';\nimport type BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\nimport type { LedgerTransport, LedgerWalletInfo } from './types';\nimport { ApiLiquidUnstakeMode, ApiTransactionError } from '../../api/types';\n\nimport {\n  BURN_ADDRESS, ETHENA_STAKING_VAULT, IS_CAPACITOR, LIQUID_JETTON, LIQUID_POOL,\n  NOTCOIN_EXCHANGERS, NOTCOIN_VOUCHERS_ADDRESS, TON_TSUSDE, TON_USDE, TONCOIN,\n} from '../../config';\nimport { callApi } from '../../api';\nimport {\n  DEFAULT_IS_BOUNCEABLE,\n  NFT_TRANSFER_AMOUNT,\n  NFT_TRANSFER_FORWARD_AMOUNT,\n  STAKE_COMMENT,\n  TOKEN_TRANSFER_FORWARD_AMOUNT,\n  TON_GAS,\n  TRANSFER_TIMEOUT_SEC,\n  UNSTAKE_COMMENT,\n  WALLET_IS_BOUNCEABLE,\n  WORKCHAIN,\n  Workchain,\n} from '../../api/chains/ton/constants';\nimport {\n  buildJettonClaimPayload,\n  buildJettonUnstakePayload,\n  buildLiquidStakingWithdrawCustomPayload,\n  commentToBytes,\n  packBytesAsSnakeCell,\n  toBase64Address,\n} from '../../api/chains/ton/util/tonCore';\nimport {\n  ApiHardwareBlindSigningNotEnabled,\n  ApiUnsupportedVersionError,\n  ApiUserRejectsError,\n  handleServerError,\n} from '../../api/errors';\nimport { parseAccountId } from '../account';\nimport compareVersions from '../compareVersions';\nimport { logDebugError } from '../logs';\nimport { pause } from '../schedulers';\nimport { IS_ANDROID_APP } from '../windowEnvironment';\nimport { isLedgerConnectionBroken, isValidLedgerComment } from './utils';\n\nimport { DnsItem } from '../../api/chains/ton/contracts/DnsItem';\nimport { TsUSDeWallet } from '../../api/chains/ton/contracts/Ethena/TsUSDeWallet';\nimport { StakingPool } from '../../api/chains/ton/contracts/JettonStaking/StakingPool';\n\ntype BleConnectorClass = typeof import('./bleConnector').BleConnector;\ntype HIDTransportClass = typeof import('@mytonwallet/capacitor-usb-hid/dist/esm').HIDTransport;\ntype ListLedgerDevicesFunction = typeof import('@mytonwallet/capacitor-usb-hid/dist/esm').listLedgerDevices;\n\ntype TransactionParams = {\n  to: Address;\n  sendMode: SendMode;\n  seqno: number;\n  timeout: number;\n  bounce: boolean;\n  amount: bigint;\n  stateInit?: StateInit;\n  payload?: TonPayloadFormat;\n  walletSpecifiers?: {\n    subwalletId?: number;\n    includeWalletOp: boolean;\n  };\n};\n\nexport type PossibleWalletVersion = 'v3R2' | 'v4R2';\n\ntype PartialLocalActivity = Partial<ApiLocalTransactionParams> & {\n  fee: bigint;\n};\n\nenum LedgerWalletVersion {\n  v3R2 = 'v3r2',\n  v4R2 = 'v4',\n}\n\nconst INTERNAL_WORKCHAIN = 0; // workchain === -1 ? 255 : 0;\nconst DEFAULT_WALLET_VERSION: PossibleWalletVersion = 'v4R2';\n\nconst DEVICE_DETECT_ATTEMPTS = 3;\nconst ATTEMPTS = 10;\nconst PAUSE = 125;\nconst IS_BOUNCEABLE = false;\nconst VERSION_WITH_UNSAFE = '2.1.0';\nconst VERSION_WITH_JETTON_ID = '2.2.0';\nconst VESTING_SUBWALLET_ID = 0x10C;\n\nconst knownJettonAddresses = KNOWN_JETTONS.map(\n  ({ masterAddress }) => masterAddress.toString({ bounceable: true, urlSafe: true }),\n);\n\nlet transport: TransportWebHID | TransportWebUSB | BleTransport | HIDTransport | undefined;\nlet tonTransport: TonTransport | undefined;\nlet transportSupport: {\n  hid: boolean;\n  webUsb: boolean;\n  bluetooth: boolean;\n} | undefined;\nlet currentLedgerTransport: LedgerTransport | undefined;\n\nlet hidImportPromise: Promise<{\n  transport: HIDTransportClass;\n  listLedgerDevices: ListLedgerDevicesFunction;\n}> | undefined;\nlet bleImportPromise: Promise<BleConnectorClass> | undefined;\nlet BleConnector: BleConnectorClass;\nlet MtwHidTransport: HIDTransportClass;\nlet listLedgerDevices: ListLedgerDevicesFunction;\n\nasync function ensureBleConnector() {\n  if (!IS_CAPACITOR) return undefined;\n\n  if (!bleImportPromise) {\n    bleImportPromise = import('./bleConnector').then((module) => {\n      return module.BleConnector;\n    });\n    BleConnector = await bleImportPromise;\n  }\n\n  return bleImportPromise;\n}\n\nasync function ensureHidTransport() {\n  if (!IS_ANDROID_APP) return undefined;\n\n  if (!hidImportPromise) {\n    hidImportPromise = import('@mytonwallet/capacitor-usb-hid/dist/esm').then((module) => {\n      return {\n        transport: module.HIDTransport,\n        listLedgerDevices: module.listLedgerDevices,\n      };\n    });\n    const result = await hidImportPromise;\n    MtwHidTransport = result.transport;\n    listLedgerDevices = result.listLedgerDevices;\n  }\n\n  return hidImportPromise;\n}\n\nvoid ensureBleConnector();\nvoid ensureHidTransport();\n\nexport async function detectAvailableTransports() {\n  await ensureBleConnector();\n  await ensureHidTransport();\n  const [hid, bluetooth, webUsb] = await Promise.all([\n    IS_ANDROID_APP ? MtwHidTransport.isSupported() : TransportWebHID.isSupported(),\n    BleConnector ? BleConnector.isSupported() : false,\n    TransportWebUSB.isSupported(),\n  ]);\n\n  transportSupport = { hid, bluetooth, webUsb };\n\n  return {\n    isUsbAvailable: hid || webUsb,\n    isBluetoothAvailable: bluetooth,\n  };\n}\n\nexport async function hasUsbDevice() {\n  const transportSupport = getTransportSupportOrFail();\n\n  if (transportSupport.hid) {\n    return IS_ANDROID_APP\n      ? await hasCapacitorHIDDevice()\n      : await hasWebHIDDevice();\n  }\n\n  if (transportSupport.webUsb) {\n    return await hasWebUsbDevice();\n  }\n\n  return false;\n}\n\nfunction getInternalWalletVersion(version: PossibleWalletVersion) {\n  return LedgerWalletVersion[version];\n}\n\nexport async function importLedgerWallet(network: ApiNetwork, accountIndex: number) {\n  const walletInfo = await getLedgerWalletInfo(network, accountIndex);\n  return callApi('importLedgerWallet', network, walletInfo);\n}\n\nexport async function reconnectLedger() {\n  try {\n    if (await tonTransport?.isAppOpen()) {\n      return true;\n    }\n  } catch {\n    // Do nothing\n  }\n\n  const isLedgerConnected = await connectLedger();\n  if (!isLedgerConnected) return false;\n\n  try {\n    return await waitLedgerTonApp();\n  } catch (err: any) {\n    if (isLedgerConnectionBroken(err.name)) {\n      return reconnectLedger();\n    }\n\n    throw err;\n  }\n}\n\nexport async function connectLedger(preferredTransport?: LedgerTransport) {\n  const transportSupport = getTransportSupportOrFail();\n\n  if (preferredTransport) currentLedgerTransport = preferredTransport;\n\n  try {\n    switch (currentLedgerTransport) {\n      case 'bluetooth':\n        transport = await connectBLE();\n        break;\n\n      case 'usb':\n      default:\n        if (transportSupport.hid) {\n          transport = await connectHID();\n        } else if (transportSupport.webUsb) {\n          transport = await connectWebUsb();\n        }\n        break;\n    }\n\n    if (!transport) {\n      logDebugError('connectLedger: BLE and/or HID are not supported');\n      return false;\n    }\n\n    tonTransport = new TonTransport(transport);\n    return true;\n  } catch (err) {\n    logDebugError('connectLedger', err);\n    return false;\n  }\n}\n\nasync function waitLedgerTonAppDeadline(): Promise<boolean> {\n  await pause(PAUSE * ATTEMPTS);\n  return false;\n}\n\nexport async function checkTonApp() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    try {\n      const isTonOpen = await tonTransport?.isAppOpen();\n\n      if (isTonOpen) {\n        if (transport?.deviceModel?.id.startsWith('nanoS')) {\n          // Workaround for Ledger Nano S or Nano S Plus, this is a way to check if it is unlocked.\n          // There will be an error with code 0x530c.\n          await tonTransport?.getAddress(getLedgerAccountPathByIndex(0), {\n            walletVersion: LedgerWalletVersion[DEFAULT_WALLET_VERSION],\n          });\n        }\n\n        return true;\n      }\n    } catch (err: any) {\n      if (isLedgerConnectionBroken(err.name)) {\n        tonTransport = undefined;\n        throw err;\n      }\n      if (!err?.message.includes('0x530c')) {\n        logDebugError('waitLedgerTonApp', err);\n      }\n    }\n\n    await pause(PAUSE);\n  }\n\n  return false;\n}\n\nexport function waitLedgerTonApp() {\n  return Promise.race([\n    checkTonApp(),\n    waitLedgerTonAppDeadline(),\n  ]);\n}\n\nfunction connectHID() {\n  if (IS_ANDROID_APP) {\n    return connectCapacitorHID();\n  }\n\n  return connectWebHID();\n}\n\nasync function connectWebHID() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await TransportWebHID.list();\n\n    if (!device) {\n      await TransportWebHID.create();\n      await pause(PAUSE);\n      continue;\n    }\n\n    if (device.opened) {\n      return new TransportWebHID(device);\n    } else {\n      return TransportWebHID.open(device);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectWebUsb() {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await TransportWebUSB.list();\n\n    if (!device) {\n      await TransportWebUSB.create();\n      await pause(PAUSE);\n      continue;\n    }\n\n    if (device.opened) {\n      return (await TransportWebUSB.openConnected()) ?? (await TransportWebUSB.request());\n    } else {\n      return TransportWebUSB.open(device);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectCapacitorHID(): Promise<HIDTransport> {\n  for (let i = 0; i < ATTEMPTS; i++) {\n    const [device] = await listLedgerDevices();\n\n    if (!device) {\n      await pause(PAUSE);\n      continue;\n    }\n\n    try {\n      return await Promise.race([\n        MtwHidTransport.open(device),\n        new Promise<never>((_, reject) => {\n          setTimeout(() => reject(new Error()), 1000);\n        }),\n      ]);\n    } catch (error) {\n      await pause(PAUSE);\n    }\n  }\n\n  throw new Error('Failed to connect');\n}\n\nasync function connectBLE(): Promise<BleTransport> {\n  if (!BleConnector) {\n    throw new Error('BLE is not supported on this device.');\n  }\n\n  const connection = await BleConnector.connect();\n  return connection.bleTransport;\n}\n\nexport async function submitLedgerStake(\n  accountId: string,\n  amount: bigint,\n  state: ApiStakingState,\n  realFee = 0n,\n) {\n  const address = await callApi('fetchAddress', accountId, 'ton');\n\n  let result: string | { error: ApiTransactionError } | undefined;\n  const localTransactionParams: PartialLocalActivity = { type: 'stake', fee: realFee };\n\n  switch (state.type) {\n    case 'nominators': {\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: state.pool,\n        amount: amount + TON_GAS.stakeNominators,\n        comment: STAKE_COMMENT,\n      }, TONCOIN.slug, localTransactionParams);\n      break;\n    }\n    case 'liquid': {\n      const payload: TonPayloadFormat = {\n        type: 'tonstakers-deposit',\n        queryId: 0n,\n        // eslint-disable-next-line no-null/no-null\n        appId: null,\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: LIQUID_POOL,\n        amount: amount + TON_GAS.stakeLiquid,\n      }, TONCOIN.slug, localTransactionParams, payload);\n      break;\n    }\n    case 'jetton': {\n      const {\n        pool: poolAddress,\n        period,\n        tokenAddress,\n        tokenSlug,\n      } = state;\n\n      Object.assign(localTransactionParams, {\n        inMsgHash: undefined,\n        slug: tokenSlug,\n        toAddress: poolAddress,\n      });\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: poolAddress,\n        tokenAddress,\n        amount,\n        data: StakingPool.stakePayload(period),\n        forwardAmount: TON_GAS.stakeJettonsForward,\n      }, TONCOIN.slug, localTransactionParams);\n      break;\n    }\n    case 'ethena': {\n      localTransactionParams.toAddress = ETHENA_STAKING_VAULT;\n      localTransactionParams.slug = state.tokenSlug;\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: ETHENA_STAKING_VAULT,\n        tokenAddress: TON_USDE.tokenAddress,\n        amount,\n        forwardAmount: TON_GAS.stakeEthenaForward,\n      }, TONCOIN.slug, localTransactionParams);\n    }\n  }\n\n  if (result) {\n    await callApi('updateAccountMemoryCache', accountId, address!, { stakedAt: Date.now() });\n  }\n\n  return result;\n}\n\nexport async function submitLedgerUnstake(accountId: string, state: ApiStakingState, amount: bigint, realFee = 0n) {\n  const { network } = parseAccountId(accountId);\n  const address = (await callApi('fetchAddress', accountId, 'ton'))!;\n\n  let result: string | { error: ApiTransactionError } | undefined;\n  const localActivityParams: PartialLocalActivity = { type: 'unstakeRequest', fee: realFee };\n\n  switch (state.type) {\n    case 'nominators': {\n      const poolAddress = toBase64Address(state.pool, true, network);\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: poolAddress,\n        amount: TON_GAS.unstakeNominators,\n        comment: UNSTAKE_COMMENT,\n      }, TONCOIN.slug, localActivityParams);\n      break;\n    }\n    case 'liquid': {\n      const tokenWalletAddress = await callApi('resolveTokenWalletAddress', network, address, LIQUID_JETTON);\n      const mode = !state.instantAvailable\n        ? ApiLiquidUnstakeMode.BestRate\n        : ApiLiquidUnstakeMode.Default;\n\n      const fillOrKill = false;\n      const waitTillRoundEnd = mode === ApiLiquidUnstakeMode.BestRate;\n\n      const payload: TonPayloadFormat = {\n        type: 'jetton-burn',\n        queryId: 0n,\n        amount,\n        responseDestination: Address.parse(address),\n        customPayload: buildLiquidStakingWithdrawCustomPayload(waitTillRoundEnd, fillOrKill),\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: tokenWalletAddress!,\n        amount: TON_GAS.unstakeLiquid,\n      }, TONCOIN.slug, localActivityParams, payload);\n      break;\n    }\n    case 'jetton': {\n      const { stakeWalletAddress } = state;\n      const payload: TonPayloadFormat = {\n        type: 'unsafe',\n        message: buildJettonUnstakePayload(amount, true),\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: stakeWalletAddress,\n        amount: TON_GAS.unstakeJettons,\n      }, TONCOIN.slug, localActivityParams, payload);\n      break;\n    }\n    case 'ethena': {\n      localActivityParams.amount = TON_GAS.unstakeEthena;\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: TON_TSUSDE.tokenAddress,\n        amount,\n        tokenAddress: TON_TSUSDE.tokenAddress,\n        forwardAmount: TON_GAS.unstakeEthenaForward,\n      }, TONCOIN.slug, localActivityParams);\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport async function submitLedgerStakingClaimOrUnlock(\n  accountId: string,\n  state: ApiJettonStakingState | ApiEthenaStakingState,\n  realFee = 0n,\n) {\n  const fromAddress = await callApi('fetchAddress', accountId, 'ton');\n  let result: string | { error: ApiTransactionError } | undefined;\n\n  switch (state.type) {\n    case 'jetton': {\n      const payload: TonPayloadFormat = {\n        type: 'unsafe',\n        message: buildJettonClaimPayload(state.poolWallets!),\n      };\n      const localActivityParams = { fee: realFee };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        amount: TON_GAS.claimJettons,\n        password: '',\n        toAddress: state.stakeWalletAddress,\n      }, TONCOIN.slug, localActivityParams, payload);\n      break;\n    }\n    case 'ethena': {\n      const payload: TonPayloadFormat = {\n        type: 'unsafe',\n        message: TsUSDeWallet.transferTimelockedMessage({\n          jettonAmount: state.lockedBalance,\n          to: Address.parse(TON_TSUSDE.tokenAddress),\n          responseAddress: Address.parse(fromAddress!),\n          forwardTonAmount: TON_GAS.unstakeEthenaLockedForward,\n        }),\n      };\n\n      const localActivityParams: PartialLocalActivity = {\n        type: 'unstake',\n        fee: realFee,\n      };\n\n      result = await submitLedgerTransfer({\n        accountId,\n        password: '',\n        toAddress: state.tsUsdeWalletAddress,\n        amount: TON_GAS.unstakeEthenaLocked,\n      }, TONCOIN.slug, localActivityParams, payload);\n    }\n  }\n\n  return result;\n}\n\nexport async function submitLedgerTransfer(\n  options: ApiSubmitTransferOptions & { data?: Cell },\n  slug: string,\n  localActivityParams?: PartialLocalActivity,\n  payload?: TonPayloadFormat,\n) {\n  const {\n    accountId,\n    tokenAddress,\n    comment,\n    data,\n    forwardAmount,\n  } = options;\n  let { toAddress, amount } = options;\n  const { network } = parseAccountId(accountId);\n\n  const pendingTransferId = await callApi('waitAndCreateTonPendingTransfer', accountId);\n  const fromAddress = await callApi('fetchAddress', accountId, 'ton');\n\n  const [path, walletInfo, appInfo, account] = await Promise.all([\n    getLedgerAccountPath(accountId),\n    callApi('getWalletInfo', network, fromAddress!),\n    getTonAppInfo(),\n    callApi('fetchLedgerAccount', accountId),\n  ]);\n\n  const { seqno, balance } = walletInfo!;\n\n  const parsedAddress = Address.parseFriendly(toAddress);\n  let isBounceable = parsedAddress.isBounceable;\n  const normalizedAddress = parsedAddress.address.toString({ urlSafe: true, bounceable: DEFAULT_IS_BOUNCEABLE });\n\n  const { isUnsafeSupported, isJettonIdSupported } = appInfo;\n\n  if (tokenAddress) {\n    ({ toAddress, amount, payload } = await buildLedgerTokenTransfer({\n      network,\n      tokenAddress,\n      fromAddress: fromAddress!,\n      toAddress,\n      amount,\n      data: comment || data,\n      isJettonIdSupported,\n      forwardAmount,\n    }));\n    isBounceable = true;\n  } else if (comment) {\n    if (isValidLedgerComment(comment)) {\n      payload = { type: 'comment', text: comment };\n    } else if (isUnsafeSupported) {\n      payload = { type: 'unsafe', message: buildCommentPayload(comment) };\n    } else {\n      return {\n        error: ApiTransactionError.NotSupportedHardwareOperation,\n      };\n    }\n  }\n\n  const isFullTonBalance = !tokenAddress && balance === amount;\n\n  const sendMode = (isFullTonBalance\n    ? SendMode.CARRY_ALL_REMAINING_BALANCE\n    : SendMode.PAY_GAS_SEPARATELY) + SendMode.IGNORE_ERRORS;\n\n  const walletSpecifiers = account!.ton.version === 'v3R2'\n    ? { includeWalletOp: false }\n    : undefined;\n\n  try {\n    const signedCell = await tonTransport!.signTransaction(path, {\n      to: Address.parse(toAddress),\n      sendMode,\n      seqno,\n      timeout: getTransferExpirationTime(),\n      bounce: isBounceable,\n      amount: BigInt(amount),\n      payload,\n      walletSpecifiers,\n    });\n\n    const message: ApiSignedTransfer = {\n      base64: signedCell.toBoc().toString('base64'),\n      seqno,\n      localActivity: {\n        amount: options.amount,\n        fromAddress: fromAddress!,\n        toAddress: normalizedAddress,\n        comment,\n        slug,\n        fee: 0n,\n        ...localActivityParams,\n      },\n    };\n\n    return await callApi('sendSignedTransferMessage', accountId, message, pendingTransferId!);\n  } catch (err: any) {\n    await callApi('cancelPendingTransfer', pendingTransferId!);\n\n    handleLedgerErrors(err);\n    logDebugError('submitLedgerTransfer', err);\n    return undefined;\n  }\n}\n\nexport async function submitLedgerNftTransfer(options: {\n  accountId: string;\n  password: string;\n  nftAddress: string;\n  toAddress: string;\n  comment?: string;\n  nft?: ApiNft;\n  realFee?: bigint;\n}) {\n  const {\n    accountId, nftAddress, comment, nft, realFee,\n  } = options;\n  let { toAddress } = options;\n  const { network } = parseAccountId(accountId);\n\n  const pendingTransferId = await callApi('waitAndCreateTonPendingTransfer', accountId);\n\n  const fromAddress = await callApi('fetchAddress', accountId, 'ton');\n\n  const [path, walletInfo, appInfo, account] = await Promise.all([\n    getLedgerAccountPath(accountId),\n    callApi('getWalletInfo', network, fromAddress!),\n    getTonAppInfo(),\n    callApi('fetchLedgerAccount', accountId),\n  ]);\n\n  if (!appInfo.isUnsafeSupported) {\n    return {\n      error: ApiTransactionError.NotSupportedHardwareOperation,\n    };\n  }\n\n  const { seqno } = walletInfo!;\n\n  const isNotcoinBurn = nft?.collectionAddress === NOTCOIN_VOUCHERS_ADDRESS\n    && (toAddress === BURN_ADDRESS || NOTCOIN_EXCHANGERS.includes(toAddress as any));\n  // eslint-disable-next-line no-null/no-null\n  let forwardPayload: Cell | null = null;\n  let forwardAmount = NFT_TRANSFER_FORWARD_AMOUNT;\n\n  if (isNotcoinBurn) {\n    ({ forwardPayload, toAddress } = buildNotcoinVoucherExchange(nftAddress, nft.index));\n    forwardAmount = 50000000n;\n  } else if (comment) {\n    forwardPayload = buildCommentPayload(comment);\n  }\n\n  const walletSpecifiers = account!.ton.version === 'v3R2'\n    ? { includeWalletOp: false }\n    : undefined;\n\n  try {\n    const signedCell = await tonTransport!.signTransaction(path, {\n      to: Address.parse(nftAddress),\n      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n      seqno,\n      timeout: getTransferExpirationTime(),\n      bounce: true,\n      amount: NFT_TRANSFER_AMOUNT,\n      payload: {\n        type: 'nft-transfer',\n        queryId: 0n,\n        newOwner: Address.parse(toAddress),\n        responseDestination: Address.parse(fromAddress!),\n        // eslint-disable-next-line no-null/no-null\n        customPayload: null,\n        forwardAmount,\n        forwardPayload,\n      },\n      walletSpecifiers,\n    });\n\n    const message: ApiSignedTransfer = {\n      base64: signedCell.toBoc().toString('base64'),\n      seqno,\n      localActivity: {\n        amount: 0n, // Regular NFT transfers should have no amount in the activity list\n        fromAddress: fromAddress!,\n        toAddress: options.toAddress,\n        comment,\n        fee: realFee ?? 0n,\n        slug: TONCOIN.slug,\n        nft,\n        normalizedAddress: toBase64Address(nftAddress, true, network),\n      },\n    };\n\n    return await callApi('sendSignedTransferMessage', accountId, message, pendingTransferId!);\n  } catch (error) {\n    await callApi('cancelPendingTransfer', pendingTransferId!);\n\n    logDebugError('submitLedgerNftTransfer', error);\n    return undefined;\n  }\n}\n\nfunction buildNotcoinVoucherExchange(nftAddress: string, nftIndex: number) {\n  const first4Bits = Address.parse(nftAddress).hash.readUint8() >> 4;\n  const toAddress = NOTCOIN_EXCHANGERS[first4Bits];\n\n  const forwardPayload = new Builder()\n    .storeUint(0x5fec6642, 32)\n    .storeUint(nftIndex, 64)\n    .endCell();\n\n  return { forwardPayload, toAddress };\n}\n\nexport async function buildLedgerTokenTransfer({\n  network,\n  tokenAddress,\n  fromAddress,\n  toAddress,\n  amount,\n  data,\n  isJettonIdSupported,\n  forwardAmount = TOKEN_TRANSFER_FORWARD_AMOUNT,\n}: {\n  network: ApiNetwork;\n  tokenAddress: string;\n  fromAddress: string;\n  toAddress: string;\n  amount: bigint;\n  data?: string | Cell;\n  isJettonIdSupported?: boolean;\n  forwardAmount?: bigint;\n}) {\n  const tokenWalletAddress = await callApi('resolveTokenWalletAddress', network, fromAddress, tokenAddress);\n  const realTokenAddress = await callApi('resolveTokenAddress', network, tokenWalletAddress!);\n  if (tokenAddress !== realTokenAddress) {\n    throw new Error('Invalid contract');\n  }\n\n  // eslint-disable-next-line no-null/no-null\n  const forwardPayload = typeof data === 'string' ? buildCommentPayload(data) : data ?? null;\n\n  const payload: TonPayloadFormat = {\n    type: 'jetton-transfer',\n    queryId: 0n,\n    amount,\n    destination: Address.parse(toAddress),\n    responseDestination: Address.parse(fromAddress),\n    // eslint-disable-next-line no-null/no-null\n    customPayload: null,\n    forwardAmount,\n    forwardPayload,\n    // eslint-disable-next-line no-null/no-null\n    knownJetton: isJettonIdSupported ? getKnownJettonId(tokenAddress) : null,\n  };\n\n  const tonAmountForTransfer = await callApi('getAmountForTokenTransfer', tokenAddress, false);\n  if (!tonAmountForTransfer) {\n    throw new Error('Couldn\\'t get the TON amount for transfer');\n  }\n\n  let toncoinAmount = tonAmountForTransfer.amount;\n  if (forwardAmount > TOKEN_TRANSFER_FORWARD_AMOUNT) {\n    toncoinAmount += forwardAmount;\n  }\n\n  return {\n    amount: toncoinAmount,\n    toAddress: tokenWalletAddress!,\n    payload,\n  };\n}\n\nfunction getKnownJettonId(tokenAddress: string) {\n  const index = knownJettonAddresses.indexOf(tokenAddress);\n  // eslint-disable-next-line no-null/no-null\n  return index > -1 ? { jettonId: index, workchain: WORKCHAIN } : null;\n}\n\nfunction buildCommentPayload(comment: string) {\n  const bytes = commentToBytes(comment);\n  return packBytesAsSnakeCell(bytes);\n}\n\nexport async function signLedgerTransactions(accountId: string, messages: ApiTransferToSign[], options?: {\n  isTonConnect?: boolean;\n  vestingAddress?: string;\n}): Promise<ApiSignedTransfer[]> {\n  const { isTonConnect, vestingAddress } = options ?? {};\n\n  const { network } = parseAccountId(accountId);\n\n  const [path, appInfo, account] = await Promise.all([\n    getLedgerAccountPath(accountId),\n    getTonAppInfo(),\n    callApi('fetchLedgerAccount', accountId),\n  ]);\n  const fromAddress = account!.ton.address;\n\n  const { isUnsafeSupported, isJettonIdSupported } = appInfo;\n\n  if (isTonConnect && !isUnsafeSupported) {\n    throw new ApiUnsupportedVersionError('Please update Ledger TON app.');\n  }\n\n  const seqno = await callApi('getWalletSeqno', accountId, vestingAddress);\n  let walletSpecifiers: TransactionParams['walletSpecifiers'];\n  if (account!.ton.version === 'v3R2') {\n    walletSpecifiers = { includeWalletOp: false };\n  }\n  if (vestingAddress) {\n    walletSpecifiers = { subwalletId: VESTING_SUBWALLET_ID, includeWalletOp: false };\n  }\n\n  const preparedParams: TransactionParams[] = await Promise.all(messages.map(async (message, index) => {\n    const {\n      toAddress,\n      amount,\n      stateInit: stateInitBase64,\n      rawPayload,\n    } = message;\n\n    const isBounceable = Address.isFriendly(toAddress)\n      ? Address.parseFriendly(toAddress).isBounceable\n      : DEFAULT_IS_BOUNCEABLE;\n\n    let ledgerPayload: TonPayloadFormat | undefined;\n\n    if (rawPayload) {\n      ledgerPayload = parseMessage(Cell.fromBase64(rawPayload), { disallowModification: true });\n    }\n\n    if (ledgerPayload?.type === 'jetton-transfer') {\n      const tokenAddress = await callApi('resolveTokenAddress', network, toAddress);\n      // eslint-disable-next-line no-null/no-null\n      ledgerPayload.knownJetton = isJettonIdSupported ? getKnownJettonId(tokenAddress!) : null;\n    }\n\n    const stateInit = stateInitBase64 ? loadStateInit(\n      Cell.fromBase64(stateInitBase64).asSlice(),\n    ) : undefined;\n\n    return {\n      to: Address.parse(toAddress),\n      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,\n      seqno: seqno! + index,\n      timeout: getTransferExpirationTime(),\n      bounce: isBounceable,\n      amount: BigInt(amount),\n      payload: ledgerPayload,\n      walletSpecifiers,\n      stateInit,\n    };\n  }));\n\n  const signedMessages: ApiSignedTransfer[] = [];\n\n  const attempts = ATTEMPTS + preparedParams.length;\n  let index = 0;\n  let attempt = 0;\n\n  while (index < preparedParams.length && attempt < attempts) {\n    const params = preparedParams[index];\n    const message = messages[index];\n\n    try {\n      const base64 = (await tonTransport!.signTransaction(path, params)).toBoc().toString('base64');\n      signedMessages.push({\n        base64,\n        seqno: params.seqno,\n        localActivity: {\n          amount: message.amount,\n          fromAddress,\n          toAddress: message.toAddress,\n          comment: message.payload?.type === 'comment' ? message.payload.comment : undefined,\n          fee: 0n,\n          slug: TONCOIN.slug,\n        },\n      });\n      index++;\n    } catch (err: any) {\n      handleLedgerErrors(err);\n      logDebugError('signLedgerTransactions', err);\n    }\n    attempt++;\n  }\n\n  return signedMessages;\n}\n\nexport async function signLedgerProof(accountId: string, proof: ApiTonConnectProof): Promise<string> {\n  const path = await getLedgerAccountPath(accountId);\n\n  const { timestamp, domain, payload } = proof;\n\n  const result = await tonTransport!.getAddressProof(path, {\n    domain,\n    timestamp,\n    payload: Buffer.from(payload),\n  });\n  return result.signature.toString('base64');\n}\n\nexport function submitLedgerDnsRenewal(\n  accountId: string,\n  nft: ApiNft,\n  realFee: bigint,\n) {\n  return submitLedgerTransfer(\n    {\n      accountId,\n      password: '',\n      toAddress: nft.address,\n      amount: TON_GAS.changeDns,\n    },\n    TONCOIN.slug,\n    { type: 'dnsRenew', fee: realFee, nft },\n    { type: 'unsafe', message: DnsItem.buildFillUpMessage() },\n  );\n}\n\nexport function submitLedgerDnsChangeWallet(\n  accountId: string,\n  nft: ApiNft,\n  newWalletAddress: string,\n  realFee: bigint,\n) {\n  return submitLedgerTransfer(\n    {\n      accountId,\n      password: '',\n      toAddress: nft.address,\n      amount: TON_GAS.changeDns,\n    },\n    TONCOIN.slug,\n    { type: 'dnsChangeAddress', fee: realFee, nft },\n    { type: 'unsafe', message: DnsItem.buildChangeDnsWalletMessage(newWalletAddress) },\n  );\n}\n\nexport async function getNextLedgerWallets(\n  network: ApiNetwork,\n  lastExistingIndex = -1,\n  alreadyImportedAddresses: string[] = [],\n) {\n  const result: LedgerWalletInfo[] = [];\n  let index = lastExistingIndex + 1;\n\n  try {\n    while (true) {\n      const walletInfo = await getLedgerWalletInfo(network, index);\n\n      if (alreadyImportedAddresses.includes(walletInfo.address)) {\n        index += 1;\n        continue;\n      }\n\n      if (walletInfo.balance !== 0n) {\n        result.push(walletInfo);\n        index += 1;\n        continue;\n      }\n\n      if (!result.length) {\n        result.push(walletInfo);\n      }\n\n      return result;\n    }\n  } catch (err) {\n    return handleServerError(err);\n  }\n}\n\nexport async function getLedgerWalletInfo(network: ApiNetwork, accountIndex: number): Promise<LedgerWalletInfo> {\n  const isTestnet = network === 'testnet';\n  const { address, publicKey } = await getLedgerWalletAddress(accountIndex, isTestnet);\n  const balance = (await callApi('getWalletBalance', 'ton', network, address))!;\n\n  return {\n    index: accountIndex,\n    address,\n    publicKey: publicKey.toString('hex'),\n    balance,\n    version: DEFAULT_WALLET_VERSION,\n    driver: 'HID',\n    deviceId: transport!.deviceModel?.id,\n    deviceName: transport!.deviceModel?.productName,\n  };\n}\n\nexport function getLedgerWalletAddress(index: number, isTestnet?: boolean) {\n  const path = getLedgerAccountPathByIndex(index);\n\n  return tonTransport!.getAddress(path, {\n    testOnly: isTestnet,\n    chain: INTERNAL_WORKCHAIN,\n    bounceable: WALLET_IS_BOUNCEABLE,\n    walletVersion: LedgerWalletVersion[DEFAULT_WALLET_VERSION],\n  });\n}\n\nexport async function verifyAddress(accountId: string) {\n  const [account, path] = await Promise.all([\n    callApi('fetchLedgerAccount', accountId),\n    getLedgerAccountPath(accountId),\n  ]);\n\n  await tonTransport!.validateAddress(path, {\n    bounceable: IS_BOUNCEABLE,\n    walletVersion: getInternalWalletVersion(account!.ton.version as PossibleWalletVersion),\n  });\n}\n\nasync function getLedgerAccountPath(accountId: string) {\n  const account = await callApi('fetchLedgerAccount', accountId);\n  const index = account!.ton.index;\n\n  return getLedgerAccountPathByIndex(index);\n}\n\nfunction getLedgerAccountPathByIndex(index: number, isTestnet?: boolean, workchain: Workchain = WORKCHAIN) {\n  const network = isTestnet ? 1 : 0;\n  const chain = workchain === Workchain.MasterChain ? 255 : 0;\n  return [44, 607, network, chain, index, 0];\n}\n\nfunction getTransferExpirationTime() {\n  return Math.floor(Date.now() / 1000 + TRANSFER_TIMEOUT_SEC);\n}\n\nexport async function getTonAppInfo() {\n  const version = await tonTransport!.getVersion();\n  const isUnsafeSupported = compareVersions(version, VERSION_WITH_UNSAFE) >= 0;\n  const isJettonIdSupported = compareVersions(version, VERSION_WITH_JETTON_ID) >= 0\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison\n    && transport!.deviceModel?.id !== 'nanoS';\n  return { version, isUnsafeSupported, isJettonIdSupported };\n}\n\nfunction handleLedgerErrors(err: any) {\n  if (err?.message.includes('(0xbd00)')) {\n    throw new ApiHardwareBlindSigningNotEnabled();\n  }\n  if (err?.statusCode === StatusCodes.CONDITIONS_OF_USE_NOT_SATISFIED) {\n    throw new ApiUserRejectsError();\n  }\n}\n\nasync function tryDetectDevice(\n  listDeviceFn: () => Promise<ICapacitorUSBDevice[]>,\n  createTransportFn?: () => Promise<unknown> | void,\n) {\n  try {\n    for (let i = 0; i < DEVICE_DETECT_ATTEMPTS; i++) {\n      const [device] = await listDeviceFn();\n      if (!device) {\n        if (createTransportFn) await createTransportFn();\n        await pause(PAUSE);\n        continue;\n      }\n\n      return true;\n    }\n  } catch (err: any) {\n    logDebugError('tryDetectDevice', err);\n  }\n\n  return false;\n}\n\nfunction hasWebHIDDevice() {\n  return tryDetectDevice(() => TransportWebHID.list(), () => TransportWebHID.create());\n}\nfunction hasWebUsbDevice() {\n  return tryDetectDevice(() => TransportWebUSB.list(), () => TransportWebUSB.create());\n}\nfunction hasCapacitorHIDDevice() {\n  return tryDetectDevice(listLedgerDevices);\n}\n\nfunction getTransportSupportOrFail() {\n  // detectAvailableTransports must be called before calling this function\n  if (!transportSupport) {\n    throw new Error('detectAvailableTransports not called');\n  }\n\n  return transportSupport;\n}\n"],"names":["dnsCategoryToBigInt","category","sha256BigInt","MAX_TIMEOUT","async","fetchWithRetry","url","init","options","retries","DEFAULT_RETRIES","timeouts","DEFAULT_TIMEOUT","shouldSkipRetryFn","isNotTemporaryError","statusCode","message","i","logDebug","toString","timeout","Array","isArray","length","Math","min","response","fetchWithTimeout","status","error","json","catch","Error","err","ApiServerError","pause","DEFAULT_ERROR_PAUSE","arguments","undefined","controller","AbortController","id","setTimeout","abort","fetch","signal","clearTimeout","includes","TON_MAX_COMMENT_BYTES","clientByNetwork","getTonClient","network","apiHeaders","toncenterMainnetKey","toncenterTestnetKey","environment","mainnet","TonClient","endpoint","TONCENTER_MAINNET_URL","apiKey","headers","testnet","TONCENTER_TESTNET_URL","toBase64Address","address","isBounceable","DEFAULT_IS_BOUNCEABLE","Address","parse","urlSafe","bounceable","testOnly","buildLiquidStakingWithdrawCustomPayload","waitTillRoundEnd","fillOrKill","Builder","storeUint","Number","asCell","buildJettonClaimPayload","poolWallets","queryId","rewardsToClaim","Dictionary","empty","Keys","Values","Bool","poolWallet","set","beginCell","JettonStakingOpCodes","CLAIM_REWARDS","storeDict","endCell","WalletContractV1R1","WalletContractV1R2","WalletContractV1R3","WalletContractV2R1","WalletContractV2R2","WalletContractV3R1","WalletContractV3R2","WalletContractV4","WalletContractV5R1","withCacheAsync","tokenAddress","minter","open","JettonMinter","getWalletAddress","tokenWalletAddress","tokenWallet","JettonWallet","getWalletData","res","runMethodWithError","hex","exit_code","stack","readBigNumber","padStart","Uint8Array","from","Buffer","poolAddress","period","tonClient","pool","StakingPool","createFromAddress","walletAddress","StakeWallet","compareVersions","versionA","versionB","partsA","split","map","partsB","max","partA","partB","LedgerWalletVersion","INTERNAL_WORKCHAIN","DEFAULT_WALLET_VERSION","DEVICE_DETECT_ATTEMPTS","ATTEMPTS","PAUSE","IS_BOUNCEABLE","VERSION_WITH_UNSAFE","VERSION_WITH_JETTON_ID","VESTING_SUBWALLET_ID","knownJettonAddresses","KNOWN_JETTONS","_ref","masterAddress","transport","tonTransport","transportSupport","currentLedgerTransport","hidImportPromise","bleImportPromise","BleConnector","MtwHidTransport","listLedgerDevices","ensureBleConnector","IS_CAPACITOR","then","module","ensureHidTransport","IS_ANDROID_APP","HIDTransport","result","detectAvailableTransports","hid","bluetooth","webUsb","Promise","all","isSupported","TransportWebHID","TransportWebUSB","isUsbAvailable","isBluetoothAvailable","hasUsbDevice","getTransportSupportOrFail","tryDetectDevice","list","create","importLedgerWallet","accountIndex","walletInfo","getLedgerWalletInfo","callApi","reconnectLedger","_tonTransport","isAppOpen","connectLedger","waitLedgerTonApp","isLedgerConnectionBroken","name","preferredTransport","connect","bleTransport","connectBLE","device","race","_","reject","connectCapacitorHID","opened","connectWebHID","openConnected","request","connectWebUsb","TonTransport","logDebugError","waitLedgerTonAppDeadline","checkTonApp","_tonTransport2","_transport","_tonTransport3","deviceModel","startsWith","getAddress","getLedgerAccountPathByIndex","walletVersion","submitLedgerStake","accountId","amount","state","realFee","localTransactionParams","type","fee","submitLedgerTransfer","password","toAddress","TON_GAS","stakeNominators","comment","STAKE_COMMENT","TONCOIN","slug","payload","appId","LIQUID_POOL","stakeLiquid","tokenSlug","Object","assign","inMsgHash","data","stakePayload","forwardAmount","stakeJettonsForward","ETHENA_STAKING_VAULT","TON_USDE","stakeEthenaForward","stakedAt","Date","now","submitLedgerUnstake","parseAccountId","localActivityParams","unstakeNominators","UNSTAKE_COMMENT","LIQUID_JETTON","instantAvailable","ApiLiquidUnstakeMode","Default","BestRate","responseDestination","customPayload","unstakeLiquid","stakeWalletAddress","jettonsToUnstake","UNSTAKE_JETTONS","storeCoins","storeBit","unstakeJettons","unstakeEthena","TON_TSUSDE","unstakeEthenaForward","submitLedgerStakingClaimOrUnlock","fromAddress","claimJettons","TsUSDeWallet","transferTimelockedMessage","jettonAmount","lockedBalance","to","responseAddress","forwardTonAmount","unstakeEthenaLockedForward","tsUsdeWalletAddress","unstakeEthenaLocked","pendingTransferId","path","appInfo","account","getLedgerAccountPath","getTonAppInfo","seqno","balance","parsedAddress","parseFriendly","normalizedAddress","isUnsafeSupported","isJettonIdSupported","buildLedgerTokenTransfer","isValidLedgerComment","text","ApiTransactionError","NotSupportedHardwareOperation","buildCommentPayload","sendMode","SendMode","PAY_GAS_SEPARATELY","CARRY_ALL_REMAINING_BALANCE","IGNORE_ERRORS","walletSpecifiers","ton","version","includeWalletOp","base64","signTransaction","getTransferExpirationTime","bounce","BigInt","toBoc","localActivity","handleLedgerErrors","submitLedgerNftTransfer","nftAddress","nft","isNotcoinBurn","collectionAddress","NOTCOIN_VOUCHERS_ADDRESS","BURN_ADDRESS","NOTCOIN_EXCHANGERS","forwardPayload","NFT_TRANSFER_FORWARD_AMOUNT","nftIndex","first4Bits","hash","readUint8","buildNotcoinVoucherExchange","index","NFT_TRANSFER_AMOUNT","newOwner","_ref2","TOKEN_TRANSFER_FORWARD_AMOUNT","destination","knownJetton","getKnownJettonId","tonAmountForTransfer","toncoinAmount","indexOf","jettonId","workchain","WORKCHAIN","bytes","buffer","startBuffer","alloc","writeUInt32BE","OpCode","Comment","commentToBytes","bytesPerCell","headCell","ceil","cellOffset","cellLength","cellBuffer","byteOffset","nextHeadCell","storeBuffer","storeRef","Cell","EMPTY","packBytesAsSnakeCell","signLedgerTransactions","messages","isTonConnect","vestingAddress","ApiUnsupportedVersionError","subwalletId","preparedParams","_ledgerPayload","stateInit","stateInitBase64","rawPayload","isFriendly","ledgerPayload","parseMessage","fromBase64","disallowModification","loadStateInit","asSlice","signedMessages","attempts","attempt","params","_message$payload","push","signLedgerProof","proof","timestamp","domain","getAddressProof","signature","submitLedgerDnsRenewal","changeDns","DnsItem","buildFillUpMessage","submitLedgerDnsChangeWallet","newWalletAddress","buildChangeDnsWalletMessage","getNextLedgerWallets","alreadyImportedAddresses","handleServerError","_deviceModel","_deviceModel2","isTestnet","publicKey","getLedgerWalletAddress","driver","deviceId","deviceName","productName","chain","WALLET_IS_BOUNCEABLE","verifyAddress","validateAddress","Workchain","MasterChain","floor","TRANSFER_TIMEOUT_SEC","_deviceModel3","getVersion","ApiHardwareBlindSigningNotEnabled","StatusCodes","CONDITIONS_OF_USE_NOT_SATISFIED","ApiUserRejectsError","listDeviceFn","createTransportFn"],"sourceRoot":""}