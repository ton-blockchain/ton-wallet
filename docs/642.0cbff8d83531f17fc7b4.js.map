{"version":3,"file":"642.0cbff8d83531f17fc7b4.js","mappings":"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","sources":["webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/monitorCharacteristic.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/remapErrors.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/BleTransport.ts","webpack://mytonwallet/./src/util/ledger/bleConnector.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/awaitsBleOn.ts"],"sourcesContent":["import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type { TraceContext } from '@ledgerhq/logs';\nimport { LocalTracer } from '@ledgerhq/logs';\nimport { Observable } from 'rxjs';\n\nimport type { Characteristic } from './types';\n\nconst LOG_TYPE = 'ble-verbose';\n\nexport const monitorCharacteristic = (\n  deviceId: string,\n  serviceId: string,\n  characteristic: Characteristic,\n  context?: TraceContext,\n): Observable<Buffer> => new Observable((o) => {\n  const tracer = new LocalTracer(LOG_TYPE, context);\n  tracer.trace('Start monitoring BLE characteristics', {\n    characteristicUuid: characteristic.uuid,\n  });\n\n  void BleClient.startNotifications(\n    deviceId,\n    serviceId,\n    characteristic.uuid,\n    (value) => {\n      const uint8Array = new Uint8Array(value.buffer);\n      const buffer = Buffer.from(uint8Array);\n      o.next(buffer);\n    },\n  );\n\n  return () => {\n    void BleClient.stopEnabledNotifications();\n  };\n});\n","import {\n  DisconnectedDevice,\n} from '@ledgerhq/errors';\n\nexport type IOBleErrorRemap = Error | null | undefined;\n\nexport const remapError = (error: IOBleErrorRemap): IOBleErrorRemap => {\n  if (!error || !error.message) return error;\n\n  if (error.message.includes('was disconnected') || error.message.includes('not found')) {\n    return new DisconnectedDevice();\n  }\n\n  return error;\n};\n\nexport const rethrowError = (e: Error | null | undefined): never => {\n  // throw remapError(e);\n  throw e ?? new Error();\n};\n\nexport const decoratePromiseErrors = <A>(promise: Promise<A>): Promise<A> => promise.catch(rethrowError);\n","/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\nimport type { BleService } from '@capacitor-community/bluetooth-le';\nimport { BleClient, ConnectionPriority } from '@capacitor-community/bluetooth-le';\nimport type { BluetoothInfos, DeviceModel } from '@ledgerhq/devices';\nimport { DeviceModelId, getBluetoothServiceUuids, getInfosForServiceUuid } from '@ledgerhq/devices';\nimport { receiveAPDU } from '@ledgerhq/devices/lib/ble/receiveAPDU';\n// ---------------------------------------------------------------------------------------------\n// Since this is a react-native library and metro bundler does not support\n// package exports yet (see: https://github.com/facebook/metro/issues/670)\n// we need to import the file directly from the lib folder.\n// Otherwise it would force the consumer of the lib to manually \"tell\" metro to resolve to /lib.\n//\n// TLDR: /!\\ Do not remove the /lib part in the import statements below (@ledgerhq/devices/lib) ! /!\\\n// See: https://github.com/LedgerHQ/ledger-live/pull/879\nimport { sendAPDU } from '@ledgerhq/devices/lib/ble/sendAPDU';\nimport type { HwTransportError } from '@ledgerhq/errors';\nimport {\n  CantOpenDevice,\n  DisconnectedDeviceDuringOperation,\n  PairingFailed,\n  TransportError,\n  TransportExchangeTimeoutError,\n} from '@ledgerhq/errors';\nimport type { Observer as TransportObserver, Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\nimport Transport from '@ledgerhq/hw-transport';\nimport type { TraceContext } from '@ledgerhq/logs';\nimport { LocalTracer, trace } from '@ledgerhq/logs';\nimport type { Observable, SchedulerLike } from 'rxjs';\nimport {\n  defer, firstValueFrom, from, merge, of, throwError, TimeoutError,\n} from 'rxjs';\nimport {\n  catchError, finalize, first, ignoreElements, map, share, tap, timeout,\n} from 'rxjs/operators';\nimport { v4 as uuid } from 'uuid';\nimport type { BleCharacteristic } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\n\nimport type { IOBleErrorRemap } from './remapErrors';\nimport type { Characteristic, Device, ReconnectionConfig } from './types';\n\nimport { awaitsBleOn } from './awaitsBleOn';\nimport { monitorCharacteristic } from './monitorCharacteristic';\nimport { decoratePromiseErrors, remapError } from './remapErrors';\n\nconst LOG_TYPE = 'ble-verbose';\n\n/**\n * This is potentially not needed anymore, to be checked if the bug is still happening.\n */\nconst reconnectionConfig: ReconnectionConfig | null | undefined = {\n  pairingThreshold: 1000,\n  delayAfterFirstPairing: 4000,\n};\n\n// Allows us to give more granulary error messages\nconst bluetoothInfoCache: Record<string, BluetoothInfos> = {};\n\nfunction retrieveInfos(device: Device | null): BluetoothInfos | undefined {\n  if (!device || !device.uuids) return undefined;\n  const [serviceUUID] = device.uuids;\n  if (!serviceUUID) return undefined;\n  const infos = getInfosForServiceUuid(serviceUUID);\n  if (!infos) return undefined;\n\n  // If we retrieved information, update the cache\n  bluetoothInfoCache[device.deviceId] = infos;\n  return infos;\n}\n\nconst delay = (ms: number | undefined) => new Promise((success) => setTimeout(success, ms));\n\n/**\n * A cache of Bluetooth transport instances associated with device IDs.\n * Allows efficient storage and retrieval of previously initialized transports.\n * @type {Object.<string, BluetoothTransport>}\n */\nconst transportsCache: Record<string, BleTransport> = {};\n\n// `connectOptions` is actually used by `react-native-ble-plx` even if comment above `ConnectionOptions` says it's not used\nconst connectOptions: Record<string, unknown> = {\n  // 156 bytes to max the iOS < 10 limit (158 bytes)\n  // (185 bytes for iOS >= 10)(up to 512 bytes for Android, but could be blocked at 23 bytes)\n  requestMTU: 156,\n  // Priority 1 = high.\n  connectionPriority: 1,\n};\n\nconst clearDisconnectTimeout = (deviceId: string, context?: TraceContext): void => {\n  const cachedTransport = transportsCache[deviceId];\n  if (cachedTransport && cachedTransport.disconnectTimeout) {\n    trace({ type: LOG_TYPE, message: 'Clearing queued disconnect', context });\n    clearTimeout(cachedTransport.disconnectTimeout);\n  }\n};\n\nlet currentDeviceService: string | undefined;\n\n/**\n * React Native bluetooth BLE implementation\n * @example\n * import BleTransport from \"@ledgerhq/react-native-hw-transport-ble\";\n */\nexport default class BleTransport extends Transport {\n  static disconnectTimeoutMs = 5000;\n\n  static list = (): Promise<void[]> => {\n    throw new Error('not implemented');\n  };\n\n  /**\n   * Scan for bluetooth Ledger devices\n   * @param observer Device is partial in order to avoid the live-common/this dep\n   * @returns TransportSubscription\n   */\n  static listen(\n    observer: TransportObserver<any, HwTransportError>,\n  ): TransportSubscription {\n    let unsubscribed: boolean = false;\n    const tracer = new LocalTracer(LOG_TYPE);\n    tracer.trace('Listening for devices ...');\n\n    void BleClient.getConnectedDevices(getBluetoothServiceUuids()).then(async (devices) => {\n      if (unsubscribed) return;\n      for (const it of devices) {\n        observer.next({\n          type: 'add',\n          device: it,\n        });\n      }\n      await BleClient.stopLEScan();\n      void BleClient.requestLEScan({\n        services: getBluetoothServiceUuids(),\n      }, (result) => {\n        if (unsubscribed) return;\n        observer.next({\n          type: 'add',\n          device: result.device,\n        });\n      });\n    });\n\n    return {\n      unsubscribe: async () => {\n        unsubscribed = true;\n        await BleClient.stopLEScan();\n      },\n    };\n  }\n\n  /**\n   * Opens a BLE transport\n   *\n   * @param {Device | string} deviceOrId\n   * @param timeoutMs Applied when trying to connect to a device\n   * @param context An optional context object for log/tracing strategy\n   * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\n   */\n  static async open(\n    deviceOrId: Device | string,\n    timeoutMs?: number,\n    context?: TraceContext,\n    { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\n  ): Promise<BleTransport> {\n    return open(deviceOrId, true, timeoutMs, context, { rxjsScheduler });\n  }\n\n  /**\n   * Exposes method from the ble-plx library to disconnect a device\n   *\n   * Disconnects from {@link Device} if it's connected or cancels pending connection.\n   * A \"disconnect\" event will normally be emitted by the ble-plx lib once the device is disconnected.\n   * Errors are logged but silenced.\n   */\n  static disconnectDevice = async (id: string,\n    onDisconnect?: (e?: Error) => void,\n    context?: TraceContext): Promise<void> => {\n    const tracer = new LocalTracer(LOG_TYPE, context);\n    tracer.trace(`Trying to disconnect device ${id}`);\n\n    try {\n      await BleClient.disconnect(id);\n      onDisconnect?.();\n    } catch (error) {\n      // Only log, ignore if disconnect did not work\n      tracer\n        .withType('ble-error')\n        .trace('Error while trying to cancel device connection', { error });\n    }\n    tracer.trace(`Device ${id} disconnected`);\n  };\n\n  device: Device;\n\n  deviceModel: DeviceModel;\n\n  // eslint-disable-next-line no-null/no-null\n  disconnectTimeout: null | ReturnType<typeof setTimeout> = null;\n\n  id: string;\n\n  isConnected = true;\n\n  mtuSize = 20;\n\n  // Observable emitting data received from the device via BLE\n  notifyObservable: Observable<Buffer | Error>;\n\n  notYetDisconnected = true;\n\n  writableWithResponseCharacteristic: Characteristic;\n\n  writableWithoutResponseCharacteristic: Characteristic | undefined;\n\n  rxjsScheduler?: SchedulerLike;\n\n  // Transaction ids of communication operations that are currently pending\n  currentTransactionIds: Array<string>;\n\n  onDisconnect: ((error?: Error) => void) | undefined;\n\n  disconnectCallback: (() => void) | undefined;\n\n  /**\n   * The static `open` function is used to handle `BleTransport` instantiation\n   *\n   * @param device\n   * @param writableWithResponseCharacteristic A BLE characteristic that we can write on,\n   *   and that will be acknowledged in response from the device when it receives the written value.\n   * @param writableWithoutResponseCharacteristic A BLE characteristic that we can write on,\n   *   and that will not be acknowledged in response from the device\n   * @param notifyObservable A multicast observable that emits messages received from the device\n   * @param deviceModel\n   * @param params Contains optional options and injected dependencies used by the transport implementation\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default: AsyncScheduler.\n   */\n  constructor(\n    device: Device,\n    writableWithResponseCharacteristic: Characteristic,\n    writableWithoutResponseCharacteristic: Characteristic | undefined,\n    notifyObservable: Observable<Buffer | Error>,\n    deviceModel: DeviceModel,\n    { context, rxjsScheduler }: { context?: TraceContext; rxjsScheduler?: SchedulerLike } = {},\n  ) {\n    super({ context, logType: LOG_TYPE });\n    this.id = device.deviceId;\n    this.device = device;\n    this.writableWithResponseCharacteristic = writableWithResponseCharacteristic;\n    this.writableWithoutResponseCharacteristic = writableWithoutResponseCharacteristic;\n    this.notifyObservable = notifyObservable;\n    this.deviceModel = deviceModel;\n    this.rxjsScheduler = rxjsScheduler;\n    this.currentTransactionIds = [];\n\n    clearDisconnectTimeout(this.id);\n\n    this.tracer.trace(`New instance of BleTransport for device ${this.id}`);\n  }\n\n  /**\n   * A message exchange (APDU request <-> response) with the device that can be aborted.\n   *\n   * The message will be BLE-encoded/framed before being sent, and the response will be BLE-decoded.\n   *\n   * @param message A buffer (u8 array) of a none BLE-encoded message (an APDU for ex) to be sent to the device\n   *   as a request\n   * @param options Contains optional options for the exchange function\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\n   * @returns A promise that resolves with the response data from the device.\n   */\n  exchange = (\n    message: Buffer,\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\n  ): Promise<Buffer> => {\n    if (this.exchangeBusyPromise) {\n      void BleTransport.disconnectDevice(this.id, this.onDisconnect);\n    }\n    const tracer = this.tracer.withUpdatedContext({\n      function: 'exchange',\n    });\n    tracer.trace('Exchanging APDU ...', { abortTimeoutMs });\n    tracer.withType('apdu').trace(`=> ${message.toString('hex')}`);\n\n    return this.exchangeAtomicImpl(() => {\n      return firstValueFrom(\n        // `sendApdu` will only emit if an error occurred, otherwise it will complete,\n        // while `receiveAPDU` will emit the full response.\n        // Consequently, it monitors the response while being able to reject on an error from the send.\n        merge(\n          this.notifyObservable.pipe((data) => receiveAPDU(data, { context: tracer.getContext() })),\n          sendAPDU(this.write, message, this.mtuSize, {\n            context: tracer.getContext(),\n          }),\n        ).pipe(\n          abortTimeoutMs ? timeout(abortTimeoutMs, this.rxjsScheduler) : tap(),\n          tap((data) => {\n            tracer.withType('apdu').trace(`<= ${data.toString('hex')}`);\n          }),\n          catchError(async (error) => {\n            // Currently only 1 reason the exchange has been explicitly aborted (other than job and transport errors): a timeout\n            if (error instanceof TimeoutError) {\n              tracer.trace(\n                'Aborting due to timeout and trying to cancel all communication write of the current exchange',\n                {\n                  abortTimeoutMs,\n                  transactionIds: this.currentTransactionIds,\n                },\n              );\n\n              // No concurrent exchange should happen at the same time, so all pending operations are part of the same exchange\n              await this.cancelPendingOperations();\n\n              throw new TransportExchangeTimeoutError('Exchange aborted due to timeout');\n            }\n\n            tracer.withType('ble-error').trace('Error while exchanging APDU', { error });\n\n            if (this.notYetDisconnected) {\n              // In such case we will always disconnect because something is bad.\n              // This sends a `disconnect` event.\n              await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n            }\n\n            const mappedError = remapError(error as IOBleErrorRemap);\n            tracer.trace('Error while exchanging APDU, mapped and throws following error', {\n              mappedError,\n            });\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\n            throw mappedError;\n          }),\n          finalize(() => {\n            tracer.trace('Clearing current transaction ids', {\n              currentTransactionIds: this.currentTransactionIds,\n            });\n            this.clearCurrentTransactionIds();\n          }),\n        ),\n      );\n    });\n  };\n\n  private async cancelPendingOperations() {\n    // BleTransport does not support cancellation\n    await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n  }\n\n  /**\n   * Sets the collection of current transaction ids to an empty array\n   */\n  private clearCurrentTransactionIds() {\n    this.currentTransactionIds = [];\n  }\n\n  /**\n   * Negotiate with the device the maximum transfer unit for the ble frames\n   * @returns Promise<number>\n   */\n  async inferMTU(): Promise<number> {\n    let mtu = (await BleClient.getMtu(this.device.deviceId));\n    this.tracer.trace('Inferring MTU ...', { currentDeviceMtu: mtu });\n\n    await this.exchangeAtomicImpl(async () => {\n      try {\n        mtu = await firstValueFrom(\n          merge(\n            this.notifyObservable.pipe(\n              map((maybeError) => {\n                // Catches the `PairingFailed` Error that has only been emitted\n                if (maybeError instanceof Error) {\n                  throw maybeError;\n                }\n\n                return maybeError;\n              }),\n              first((buffer) => buffer.readUInt8(0) === 0x08),\n              map((buffer) => buffer.readUInt8(5)),\n            ),\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(ignoreElements()),\n          ),\n        );\n      } catch (error: any) {\n        this.tracer.withType('ble-error').trace('Error while inferring MTU', { mtu });\n\n        await BleTransport.disconnectDevice(this.id, this.onDisconnect);\n\n        const mappedError = remapError(error);\n        this.tracer.trace('Error while inferring APDU, mapped and throws following error', {\n          mappedError,\n        });\n        // eslint-disable-next-line @typescript-eslint/only-throw-error\n        throw mappedError;\n      } finally {\n        // When negotiating the MTU, a message is sent/written to the device, and a transaction id was associated to this write\n        this.clearCurrentTransactionIds();\n      }\n    });\n\n    this.tracer.trace('Successfully negotiated MTU with device', {\n      mtu,\n      mtuSize: this.mtuSize,\n    });\n    if (mtu > 20) {\n      this.mtuSize = mtu;\n    }\n\n    return this.mtuSize;\n  }\n\n  /**\n   * Exposed method from the ble-plx library.\n   * Request the connection priority for the given device.\n   * @returns {Promise<void>}\n   * @param connectionPriority\n   */\n  async requestConnectionPriority(\n    connectionPriority: 'Balanced' | 'High' | 'LowPower',\n  ): Promise<void> {\n    let connectionPriorityMapped: ConnectionPriority;\n    switch (connectionPriority) {\n      case 'High':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\n        break;\n      case 'LowPower':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_LOW_POWER;\n        break;\n      case 'Balanced':\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\n        break;\n    }\n    await decoratePromiseErrors(\n      BleClient.requestConnectionPriority(this.device.deviceId, connectionPriorityMapped),\n    );\n  }\n\n  /**\n   * Do not call this directly unless you know what you're doing. Communication\n   * with a Ledger device should be through the {@link exchange} method.\n   *\n   * For each call a transaction id is added to the current stack of transaction ids.\n   * With this transaction id, a pending BLE communication operations can be cancelled.\n   * Note: each frame/packet of a longer BLE-encoded message to be sent should have their unique transaction id.\n   *\n   * @param buffer BLE-encoded packet to send to the device\n   * @param frameId Frame id to make `write` aware of a bigger message that this frame/packet is part of.\n   *  Helps to create related a collection of transaction ids\n   */\n  write = async (buffer: Buffer): Promise<void> => {\n    const transactionId = uuid();\n    this.currentTransactionIds.push(transactionId);\n\n    const tracer = this.tracer.withUpdatedContext({ transactionId });\n    tracer.trace('Writing to device', {\n      willMessageBeAcked: !this.writableWithoutResponseCharacteristic,\n    });\n\n    try {\n      const uint8Array = new Uint8Array(buffer);\n      const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n      await BleClient.write(\n        this.device.deviceId,\n        currentDeviceService!,\n        this.writableWithResponseCharacteristic.uuid,\n        dataView,\n      );\n      tracer.withType('ble-frame').trace(`=> ${buffer.toString('hex')}`);\n    } catch (error: unknown) {\n      tracer.trace('Error while writing APDU', { error });\n      throw new DisconnectedDeviceDuringOperation(\n        error instanceof Error ? error.message : `${String(error)}`,\n      );\n    }\n  };\n\n  /**\n   * We intentionally do not immediately close a transport connection.\n   * Instead, we queue the disconnect and wait for a future connection to dismiss the event.\n   * This approach prevents unnecessary disconnects and reconnects. We use the isConnected\n   * flag to ensure that we do not trigger a disconnect if the current cached transport has\n   * already been disconnected.\n   * @returns {Promise<void>}\n   */\n  async close(): Promise<void> {\n    const tracer = this.tracer.withUpdatedContext({ function: 'close' });\n    tracer.trace('Closing, queuing a disconnect with a timeout ...');\n\n    let resolve: (value: void | PromiseLike<void>) => void;\n    const disconnectPromise = new Promise<void>((innerResolve) => {\n      resolve = innerResolve;\n    });\n\n    clearDisconnectTimeout(this.id);\n\n    this.disconnectTimeout = setTimeout(() => {\n      tracer.trace('Disconnect timeout has been reached ...');\n      if (this.isConnected) {\n        BleTransport.disconnectDevice(this.id, this.onDisconnect, tracer.getContext())\n          .catch(() => {})\n          .finally(resolve);\n      } else {\n        resolve();\n      }\n    }, BleTransport.disconnectTimeoutMs);\n\n    // The closure will occur no later than 5s, triggered either by disconnection\n    // or the actual response of the apdu.\n    await Promise.race([this.exchangeBusyPromise || Promise.resolve(), disconnectPromise]);\n  }\n}\n\n/**\n * Opens a BLE connection with a given device. Returns a Transport instance.\n *\n * @param deviceOrId\n * @param needsReconnect\n * @param timeoutMs Optional Timeout (in ms) applied during the connection with the device\n * @param context Optional tracing/log context\n * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\n *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\n * @returns A BleTransport instance\n */\nasync function open(\n  deviceOrId: Device | string,\n  needsReconnect: boolean,\n  timeoutMs?: number,\n  context?: TraceContext,\n  { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\n) {\n  const tracer = new LocalTracer(LOG_TYPE, context);\n  let device: Device;\n  tracer.trace(`Opening ${typeof deviceOrId === 'string' ? deviceOrId : deviceOrId.deviceId}`, { needsReconnect });\n  let deviceId: string;\n  // eslint-disable-next-line prefer-const\n  let transport: BleTransport;\n\n  if (typeof deviceOrId === 'string') {\n    deviceId = deviceOrId;\n    if (transportsCache[deviceOrId]) {\n      tracer.trace('Transport in cache, using it');\n      clearDisconnectTimeout(deviceOrId);\n\n      // The cached transport probably has an older trace/log context\n      transportsCache[deviceOrId].setTraceContext(context);\n      return transportsCache[deviceOrId];\n    }\n\n    tracer.trace(`Trying to open device: ${deviceOrId}`);\n    await awaitsBleOn();\n\n    // Returns a list of known devices by their identifiers\n    const devices = (await BleClient.getDevices([deviceOrId]));\n    tracer.trace(`Found ${devices.length} already known device(s) with given id`, { deviceOrId });\n    [device] = devices;\n\n    if (!device) {\n      // Returns a list of the peripherals currently connected to the system\n      // which have discovered services, connected to system doesn't mean\n      // connected to our app, we check that below.\n      const services = (await BleClient.getServices(deviceOrId)).map((it) => it.uuid);\n      const connectedDevices = (await BleClient.getConnectedDevices(services));\n      const connectedDevicesFiltered = connectedDevices.filter((d) => d.deviceId === deviceOrId);\n      tracer.trace(\n        `No known device with given id.\n        Found ${connectedDevicesFiltered.length} devices from already connected devices`,\n        { deviceOrId },\n      );\n      [device] = connectedDevicesFiltered;\n    }\n\n    if (!device) {\n      // We still don't have a device, so we attempt to connect to it.\n      tracer.trace('No known nor connected devices with given id. Trying to connect to device', {\n        deviceOrId,\n        timeoutMs,\n      });\n\n      // Nb ConnectionOptions dropped since it's not used internally by ble-plx.\n      try {\n        await BleClient.connect(deviceOrId, () => {\n          transport.onDisconnect?.();\n        }, {\n          timeout: timeoutMs,\n        });\n      } catch (e: any) {\n        tracer.trace(`Error code: ${e.errorCode}`);\n        throw e;\n      }\n    }\n\n    if (!device) {\n      throw new CantOpenDevice();\n    }\n  } else {\n    // It was already a Device\n    device = deviceOrId;\n    deviceId = deviceOrId.deviceId;\n  }\n\n  const connectedDevices = await BleClient.getConnectedDevices(getBluetoothServiceUuids());\n\n  if (!connectedDevices.find((it) => it.deviceId === deviceId)) {\n    tracer.trace('Device found but not connected. connecting...', { timeoutMs, connectOptions });\n    try {\n      await BleClient.connect(deviceId, () => {\n        transport.onDisconnect?.();\n      }, {\n        timeout: timeoutMs,\n      });\n    } catch (error: any) {\n      tracer.trace('Connect error', { error });\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\n      throw remapError(error);\n    }\n  }\n\n  tracer.trace('Device is connected now, getting services and characteristics');\n\n  let services: BleService[] = [];\n\n  await BleClient.discoverServices(deviceId);\n  services = (await BleClient.getServices(deviceId));\n\n  let res: BluetoothInfos | undefined = retrieveInfos(device);\n  const characteristics: BleCharacteristic[] = [];\n\n  if (!res) {\n    for (const serviceUUID of getBluetoothServiceUuids()) {\n      try {\n        const deviceService = services.find((it) => it.uuid === serviceUUID);\n        res = getInfosForServiceUuid(serviceUUID);\n        if (res && deviceService) {\n          characteristics.push(...deviceService.characteristics);\n          currentDeviceService = res.serviceUuid;\n          break;\n        }\n      } catch (e) {\n        // Attempt to connect to the next service\n      }\n    }\n  }\n\n  if (!res) {\n    tracer.trace('Service not found');\n    throw new TransportError('service not found', 'BLEServiceNotFound');\n  }\n\n  const {\n    deviceModel, writeUuid, writeCmdUuid, notifyUuid,\n  } = res;\n\n  /* if (!characteristics) {\n    characteristics = await device.characteristicsForService(serviceUuid);\n  } */\n\n  if (!characteristics) {\n    tracer.trace('Characteristics not found');\n    throw new TransportError('service not found', 'BLEServiceNotFound');\n  }\n\n  let writableWithResponseCharacteristic: Characteristic | null | undefined;\n  let writableWithoutResponseCharacteristic: Characteristic | undefined;\n  // A characteristic that can monitor value changes\n  let notifiableCharacteristic: Characteristic | null | undefined;\n\n  for (const c of characteristics) {\n    if (c.uuid === writeUuid) {\n      writableWithResponseCharacteristic = c;\n    } else if (c.uuid === writeCmdUuid) {\n      writableWithoutResponseCharacteristic = c;\n    } else if (c.uuid === notifyUuid) {\n      notifiableCharacteristic = c;\n    }\n  }\n\n  if (!writableWithResponseCharacteristic) {\n    throw new TransportError('write characteristic not found', 'BLECharacteristicNotFound');\n  }\n\n  if (!notifiableCharacteristic) {\n    throw new TransportError('notify characteristic not found', 'BLECharacteristicNotFound');\n  }\n\n  if (!writableWithResponseCharacteristic.properties.write) {\n    throw new TransportError(\n      'The writable-with-response characteristic is not writable with response',\n      'BLECharacteristicInvalid',\n    );\n  }\n\n  if (!notifiableCharacteristic.properties.notify) {\n    throw new TransportError('notify characteristic not notifiable', 'BLECharacteristicInvalid');\n  }\n\n  if (writableWithoutResponseCharacteristic) {\n    if (!writableWithoutResponseCharacteristic.properties.writeWithoutResponse) {\n      throw new TransportError(\n        'The writable-without-response characteristic is not writable without response',\n        'BLECharacteristicInvalid',\n      );\n    }\n  }\n\n  const deviceMtu = await BleClient.getMtu(device.deviceId);\n  tracer.trace(`device.mtu=${deviceMtu}`);\n\n  // Inits the observable that will emit received data from the device via BLE\n  const notifyObservable = monitorCharacteristic(deviceId,\n    currentDeviceService!,\n    notifiableCharacteristic,\n    context).pipe(\n    catchError((e) => {\n      // LL-9033 fw 2.0.2 introduced this case, we silence the inner unhandled error.\n      // It will be handled when negotiating the MTU in `inferMTU` but will be ignored in other cases.\n      const msg = String(e);\n      return msg.includes('notify change failed')\n        ? of(new PairingFailed(msg))\n        : throwError(() => e);\n    }),\n    tap((value) => {\n      if (value instanceof PairingFailed) return;\n      trace({ type: 'ble-frame', message: `<= ${value.toString('hex')}`, context });\n    }),\n    // Returns a new Observable that multicasts (shares) the original Observable.\n    // As long as there is at least one Subscriber this Observable will be subscribed and emitting data.\n    share(),\n  );\n\n  // Keeps the input from the device observable alive (multicast observable)\n  const notif = notifyObservable.subscribe();\n\n  transport = new BleTransport(\n    device,\n    writableWithResponseCharacteristic,\n    writableWithoutResponseCharacteristic,\n    notifyObservable,\n    deviceModel,\n    {\n      context,\n      rxjsScheduler,\n    },\n  );\n  tracer.trace('New BleTransport created');\n\n  // Keeping it as a comment for now but if no new bluetooth issues occur, we will be able to remove it\n  // await transport.requestConnectionPriority(\"High\");\n\n  // let disconnectedSub: Subscription;\n\n  // Callbacks on `react-native-ble-plx` notifying the device has been disconnected\n  transport.onDisconnect = (error?: Error) => {\n    transport.isConnected = false;\n    transport.notYetDisconnected = false;\n    notif.unsubscribe();\n    // disconnectedSub?.remove();\n\n    clearDisconnectTimeout(transport.id);\n    delete transportsCache[transport.id];\n    tracer.trace(\n      `On device disconnected callback: cleared cached transport for ${transport.id},\n      emitting Transport event \"disconnect. Error: ${error}\"`,\n      { reason: error },\n    );\n    transport.emit('disconnect', error);\n    transport.disconnectCallback?.();\n  };\n\n  transportsCache[transport.id] = transport;\n  const beforeMTUTime = Date.now();\n\n  /* disconnectedSub = device.onDisconnected((e) => {\n    if (!transport.notYetDisconnected) return;\n    onDisconnect(e);\n  }); */\n\n  try {\n    await transport.inferMTU();\n  } finally {\n    const afterMTUTime = Date.now();\n\n    if (reconnectionConfig) {\n      // Refer to ledgerjs archived repo issue #279.\n      // All HW .v1 LNX have a bug that prevents us from communicating with the device right after pairing.\n      // When we connect for the first time we issue a disconnect and reconnect, this guarantees that we are\n      // in a good state. This is avoidable in some key scenarios ↓\n      if (afterMTUTime - beforeMTUTime < reconnectionConfig.pairingThreshold) {\n        needsReconnect = false;\n      } else if (deviceModel.id === DeviceModelId.stax) {\n        tracer.trace('Skipping \"needsReconnect\" strategy for Stax');\n        needsReconnect = false;\n      }\n\n      if (needsReconnect) {\n        tracer.trace('Device needs reconnection. Triggering a disconnect');\n        await BleTransport.disconnectDevice(transport.id, transport.onDisconnect);\n        await delay(reconnectionConfig.delayAfterFirstPairing);\n      }\n    } else {\n      needsReconnect = false;\n    }\n  }\n\n  if (needsReconnect) {\n    tracer.trace('Reconnecting');\n    return open(device, false, timeoutMs, context);\n  }\n\n  return transport;\n}\n","import { BleClient } from '@capacitor-community/bluetooth-le';\nimport type { Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\nimport { v4 as uuid } from 'uuid';\nimport type { BleDevice } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\n\nimport { IS_CAPACITOR } from '../../config';\nimport BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\n\ninterface ScannedDevice {\n  identifier: string;\n  device: BleDevice;\n}\n\nexport interface LedgerConnection {\n  device: BleDevice;\n  bleTransport: BleTransport;\n}\n\nlet listeningSubscription: TransportSubscription | undefined;\n\nlet scannedDevices: ScannedDevice[] = [];\nlet pairedDevice: LedgerConnection | undefined;\nlet onLedgerConnected: ((connection: LedgerConnection) => void) | undefined;\n\nfunction isConnecting() {\n  return !!listeningSubscription;\n}\n\nfunction scannedDeviceIsValidYet(scannedDevice: ScannedDevice): boolean {\n  if (!scannedDevices.find((it) => it.identifier === scannedDevice.identifier)) {\n    // List is already cleared\n    return false;\n  }\n\n  // A device is already paired\n  return !pairedDevice;\n}\n\nasync function tryConnectingLedgerDevice(scannedDevice: ScannedDevice) {\n  try {\n    // Check if stopped before retry\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\n\n    const bleTransport = await BleTransport.open(scannedDevice.device);\n    // Check if stopped before connection establish\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\n\n    const ledgerConnection = {\n      device: scannedDevice.device,\n      bleTransport,\n    };\n    pairedDevice = ledgerConnection;\n\n    bleTransport.disconnectCallback = () => {\n      pairedDevice = undefined;\n      if (isConnecting()) {\n        stop();\n        start();\n      }\n    };\n\n    setTimeout(() => {\n      // Make sure not disconnected yet\n      if (pairedDevice?.device.deviceId === ledgerConnection.device.deviceId) {\n        onLedgerConnected?.(ledgerConnection);\n        stop();\n      } else if (isConnecting()) {\n        // Unexpectedly, disconnected before calling the callback, restart!\n        pairedDevice = undefined;\n        stop();\n        void start();\n      }\n    }, 1000);\n  } catch (error) {\n    setTimeout(() => {\n      void tryConnectingLedgerDevice(scannedDevice);\n    }, 10000);\n  }\n}\n\nasync function isSupported() {\n  if (!IS_CAPACITOR) return false;\n\n  try {\n    await BleClient.initialize({\n      androidNeverForLocation: true,\n    });\n    await BleClient.requestEnable();\n  } catch (error) { /* empty */ }\n\n  return BleClient.isEnabled();\n}\n\nfunction start() {\n  listeningSubscription = BleTransport.listen({\n    next: (event: { type: string; device?: BleDevice }) => {\n      switch (event.type) {\n        case 'add':\n          if (event.device) {\n            if (!event.device.name) return;\n            if (scannedDevices.find((it) => it.device.deviceId === event.device?.deviceId)) return;\n            const scannedDevice = { identifier: uuid(), device: event.device };\n            scannedDevices.push(scannedDevice);\n            void tryConnectingLedgerDevice(scannedDevice);\n          }\n          break;\n      }\n    },\n    error: () => {\n      stop();\n    },\n    complete: () => {\n      stop();\n    },\n  });\n}\n\nfunction stop() {\n  scannedDevices = [];\n  listeningSubscription?.unsubscribe();\n  listeningSubscription = undefined;\n}\n\nfunction connect(): Promise<LedgerConnection> {\n  return new Promise((resolve) => {\n    onLedgerConnected = resolve;\n    if (pairedDevice) {\n      onLedgerConnected(pairedDevice);\n      return;\n    }\n\n    if (isConnecting()) return;\n    start();\n  });\n}\n\nexport const BleConnector = {\n  isSupported,\n  connect,\n  stop,\n};\n","import { BluetoothLe } from '@capacitor-community/bluetooth-le';\nimport { BluetoothRequired } from '@ledgerhq/errors';\n\nexport async function awaitsBleOn(): Promise<void> {\n  await BluetoothLe.initialize();\n  const isEnabled = await BluetoothLe.isEnabled();\n  if (!isEnabled) {\n    throw new BluetoothRequired('', {\n      state: 'disable',\n    });\n  }\n}\n"],"names":["remapError","error","message","includes","DisconnectedDevice","rethrowError","e","Error","LOG_TYPE","reconnectionConfig","pairingThreshold","delayAfterFirstPairing","bluetoothInfoCache","transportsCache","connectOptions","requestMTU","connectionPriority","clearDisconnectTimeout","deviceId","context","cachedTransport","disconnectTimeout","trace","type","clearTimeout","currentDeviceService","listeningSubscription","BleTransport","Transport","static","list","listen","observer","unsubscribed","LocalTracer","BleClient","getConnectedDevices","getBluetoothServiceUuids","then","async","it","devices","next","device","stopLEScan","requestLEScan","services","result","unsubscribe","open","deviceOrId","timeoutMs","rxjsScheduler","arguments","length","undefined","id","onDisconnect","tracer","disconnect","withType","isConnected","mtuSize","notYetDisconnected","constructor","writableWithResponseCharacteristic","writableWithoutResponseCharacteristic","notifyObservable","deviceModel","super","logType","this","currentTransactionIds","exchange","_this","abortTimeoutMs","exchangeBusyPromise","disconnectDevice","withUpdatedContext","function","toString","exchangeAtomicImpl","firstValueFrom","merge","pipe","data","receiveAPDU","getContext","sendAPDU","write","timeout","tap","catchError","TimeoutError","transactionIds","cancelPendingOperations","TransportExchangeTimeoutError","mappedError","finalize","clearCurrentTransactionIds","inferMTU","mtu","getMtu","currentDeviceMtu","map","maybeError","first","buffer","readUInt8","defer","from","Buffer","ignoreElements","requestConnectionPriority","connectionPriorityMapped","ConnectionPriority","CONNECTION_PRIORITY_BALANCED","CONNECTION_PRIORITY_LOW_POWER","promise","catch","transactionId","uuid","push","willMessageBeAcked","uint8Array","Uint8Array","dataView","DataView","byteOffset","byteLength","DisconnectedDeviceDuringOperation","String","close","resolve","disconnectPromise","Promise","innerResolve","setTimeout","finally","disconnectTimeoutMs","race","needsReconnect","transport","setTraceContext","BluetoothLe","initialize","isEnabled","BluetoothRequired","state","awaitsBleOn","getDevices","getServices","connectedDevicesFiltered","filter","d","connect","_transport$onDisconne","_transport","call","errorCode","CantOpenDevice","find","_transport$onDisconne2","_transport2","discoverServices","res","uuids","serviceUUID","infos","getInfosForServiceUuid","retrieveInfos","characteristics","deviceService","serviceUuid","TransportError","writeUuid","writeCmdUuid","notifyUuid","notifiableCharacteristic","c","properties","notify","writeWithoutResponse","deviceMtu","monitorCharacteristic","serviceId","characteristic","Observable","o","characteristicUuid","startNotifications","value","stopEnabledNotifications","msg","of","PairingFailed","throwError","share","notif","subscribe","_transport$disconnect","_transport3","reason","emit","disconnectCallback","beforeMTUTime","Date","now","afterMTUTime","DeviceModelId","stax","ms","success","pairedDevice","onLedgerConnected","scannedDevices","isConnecting","scannedDeviceIsValidYet","scannedDevice","identifier","tryConnectingLedgerDevice","bleTransport","ledgerConnection","stop","start","_pairedDevice","_onLedgerConnected","event","name","_event$device","complete","_listeningSubscriptio","BleConnector","isSupported","IS_CAPACITOR","androidNeverForLocation","requestEnable"],"sourceRoot":""}