"use strict";(self.webpackChunkmytonwallet=self.webpackChunkmytonwallet||[]).push([[642],{17642:(e,t,i)=>{i.r(t),i.d(t,{BleConnector:()=>G});var n=i(12757),r=i(54011),c=i(31481),o=i(71108),a=i(17276),s=i(15123),d=i(24450),u=i(13983),h=i(13648),l=i(72985),w=i(44240),v=i(9162),f=i(72316),g=i(37968),p=i(62467),m=i(13288),y=i(59099),T=i(66847),b=i(69850),D=i(81160),C=i(65277),x=i(8767),E=i(1005),I=i(93776),k=i(48287).Buffer;const F=e=>e&&e.message&&(e.message.includes("was disconnected")||e.message.includes("not found"))?new d.DisconnectedDevice:e,S=e=>{throw e??new Error};var P=i(48287).Buffer;const U="ble-verbose",M={pairingThreshold:1e3,delayAfterFirstPairing:4e3},O={},L={},A={requestMTU:156,connectionPriority:1},B=(e,t)=>{const i=L[e];i&&i.disconnectTimeout&&((0,h.trace)({type:U,message:"Clearing queued disconnect",context:t}),clearTimeout(i.disconnectTimeout))};let N,$;class R extends u.Ay{static disconnectTimeoutMs=5e3;static list=()=>{throw new Error("not implemented")};static listen(e){let t=!1;return new h.LocalTracer(U).trace("Listening for devices ..."),n.Fk.getConnectedDevices((0,o.gq)()).then((async i=>{if(!t){for(const t of i)e.next({type:"add",device:t});await n.Fk.stopLEScan(),n.Fk.requestLEScan({services:(0,o.gq)()},(i=>{t||e.next({type:"add",device:i.device})}))}})),{unsubscribe:async()=>{t=!0,await n.Fk.stopLEScan()}}}static async open(e,t,i){let{rxjsScheduler:n}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return q(e,!0,t,i,{rxjsScheduler:n})}static disconnectDevice=async(e,t,i)=>{const r=new h.LocalTracer(U,i);r.trace(`Trying to disconnect device ${e}`);try{await n.Fk.disconnect(e),null==t||t()}catch(e){r.withType("ble-error").trace("Error while trying to cancel device connection",{error:e})}r.trace(`Device ${e} disconnected`)};disconnectTimeout=null;isConnected=!0;mtuSize=20;notYetDisconnected=!0;constructor(e,t,i,n,r){let{context:c,rxjsScheduler:o}=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};super({context:c,logType:U}),this.id=e.deviceId,this.device=e,this.writableWithResponseCharacteristic=t,this.writableWithoutResponseCharacteristic=i,this.notifyObservable=n,this.deviceModel=r,this.rxjsScheduler=o,this.currentTransactionIds=[],B(this.id),this.tracer.trace(`New instance of BleTransport for device ${this.id}`)}exchange=(()=>{var e=this;return function(t){let{abortTimeoutMs:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.exchangeBusyPromise&&R.disconnectDevice(e.id,e.onDisconnect);const n=e.tracer.withUpdatedContext({function:"exchange"});return n.trace("Exchanging APDU ...",{abortTimeoutMs:i}),n.withType("apdu").trace(`=> ${t.toString("hex")}`),e.exchangeAtomicImpl((()=>(0,l._)((0,w.h)(e.notifyObservable.pipe((e=>(0,a.m)(e,{context:n.getContext()}))),(0,s.sendAPDU)(e.write,t,e.mtuSize,{context:n.getContext()})).pipe(i?(0,v.w)(i,e.rxjsScheduler):(0,y.M)(),(0,y.M)((e=>{n.withType("apdu").trace(`<= ${e.toString("hex")}`)})),(0,T.W)((async t=>{if(t instanceof v.M)throw n.trace("Aborting due to timeout and trying to cancel all communication write of the current exchange",{abortTimeoutMs:i,transactionIds:e.currentTransactionIds}),await e.cancelPendingOperations(),new d.TransportExchangeTimeoutError("Exchange aborted due to timeout");n.withType("ble-error").trace("Error while exchanging APDU",{error:t}),e.notYetDisconnected&&await R.disconnectDevice(e.id,e.onDisconnect);const r=F(t);throw n.trace("Error while exchanging APDU, mapped and throws following error",{mappedError:r}),r})),(0,b.j)((()=>{n.trace("Clearing current transaction ids",{currentTransactionIds:e.currentTransactionIds}),e.clearCurrentTransactionIds()}))))))}})();async cancelPendingOperations(){await R.disconnectDevice(this.id,this.onDisconnect)}clearCurrentTransactionIds(){this.currentTransactionIds=[]}async inferMTU(){let e=await n.Fk.getMtu(this.device.deviceId);return this.tracer.trace("Inferring MTU ...",{currentDeviceMtu:e}),await this.exchangeAtomicImpl((async()=>{try{e=await(0,l._)((0,w.h)(this.notifyObservable.pipe((0,D.T)((e=>{if(e instanceof Error)throw e;return e})),(0,C.$)((e=>8===e.readUInt8(0))),(0,D.T)((e=>e.readUInt8(5)))),(0,f.v)((()=>(0,g.H)(this.write(P.from([8,0,0,0,0]))))).pipe((0,x.w)())))}catch(t){this.tracer.withType("ble-error").trace("Error while inferring MTU",{mtu:e}),await R.disconnectDevice(this.id,this.onDisconnect);const i=F(t);throw this.tracer.trace("Error while inferring APDU, mapped and throws following error",{mappedError:i}),i}finally{this.clearCurrentTransactionIds()}})),this.tracer.trace("Successfully negotiated MTU with device",{mtu:e,mtuSize:this.mtuSize}),e>20&&(this.mtuSize=e),this.mtuSize}async requestConnectionPriority(e){let t;switch(e){case"High":case"Balanced":t=n.rj.CONNECTION_PRIORITY_BALANCED;break;case"LowPower":t=n.rj.CONNECTION_PRIORITY_LOW_POWER}var i;await(i=n.Fk.requestConnectionPriority(this.device.deviceId,t),i.catch(S))}write=async e=>{const t=(0,r.A)();this.currentTransactionIds.push(t);const i=this.tracer.withUpdatedContext({transactionId:t});i.trace("Writing to device",{willMessageBeAcked:!this.writableWithoutResponseCharacteristic});try{const t=new Uint8Array(e),r=new DataView(t.buffer,t.byteOffset,t.byteLength);await n.Fk.write(this.device.deviceId,N,this.writableWithResponseCharacteristic.uuid,r),i.withType("ble-frame").trace(`=> ${e.toString("hex")}`)}catch(e){throw i.trace("Error while writing APDU",{error:e}),new d.DisconnectedDeviceDuringOperation(e instanceof Error?e.message:`${String(e)}`)}};async close(){const e=this.tracer.withUpdatedContext({function:"close"});let t;e.trace("Closing, queuing a disconnect with a timeout ...");const i=new Promise((e=>{t=e}));B(this.id),this.disconnectTimeout=setTimeout((()=>{e.trace("Disconnect timeout has been reached ..."),this.isConnected?R.disconnectDevice(this.id,this.onDisconnect,e.getContext()).catch((()=>{})).finally(t):t()}),R.disconnectTimeoutMs),await Promise.race([this.exchangeBusyPromise||Promise.resolve(),i])}}async function q(e,t,i,r){let{rxjsScheduler:c}=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const a=new h.LocalTracer(U,r);let s,u,l;if(a.trace(`Opening ${"string"==typeof e?e:e.deviceId}`,{needsReconnect:t}),"string"==typeof e){if(u=e,L[e])return a.trace("Transport in cache, using it"),B(e),L[e].setTraceContext(r),L[e];a.trace(`Trying to open device: ${e}`),await async function(){if(await n.gq.initialize(),!await n.gq.isEnabled())throw new d.BluetoothRequired("",{state:"disable"})}();const t=await n.Fk.getDevices([e]);if(a.trace(`Found ${t.length} already known device(s) with given id`,{deviceOrId:e}),[s]=t,!s){const t=(await n.Fk.getServices(e)).map((e=>e.uuid)),i=(await n.Fk.getConnectedDevices(t)).filter((t=>t.deviceId===e));a.trace(`No known device with given id.\n        Found ${i.length} devices from already connected devices`,{deviceOrId:e}),[s]=i}if(!s){a.trace("No known nor connected devices with given id. Trying to connect to device",{deviceOrId:e,timeoutMs:i});try{await n.Fk.connect(e,(()=>{var e,t;null===(e=(t=l).onDisconnect)||void 0===e||e.call(t)}),{timeout:i})}catch(e){throw a.trace(`Error code: ${e.errorCode}`),e}}if(!s)throw new d.CantOpenDevice}else s=e,u=e.deviceId;if(!(await n.Fk.getConnectedDevices((0,o.gq)())).find((e=>e.deviceId===u))){a.trace("Device found but not connected. connecting...",{timeoutMs:i,connectOptions:A});try{await n.Fk.connect(u,(()=>{var e,t;null===(e=(t=l).onDisconnect)||void 0===e||e.call(t)}),{timeout:i})}catch(e){throw a.trace("Connect error",{error:e}),F(e)}}a.trace("Device is connected now, getting services and characteristics");let w=[];await n.Fk.discoverServices(u),w=await n.Fk.getServices(u);let v=function(e){if(!e||!e.uuids)return;const[t]=e.uuids;if(!t)return;const i=(0,o.R6)(t);return i?(O[e.deviceId]=i,i):void 0}(s);const f=[];if(!v)for(const e of(0,o.gq)())try{const t=w.find((t=>t.uuid===e));if(v=(0,o.R6)(e),v&&t){f.push(...t.characteristics),N=v.serviceUuid;break}}catch(e){}if(!v)throw a.trace("Service not found"),new d.TransportError("service not found","BLEServiceNotFound");const{deviceModel:g,writeUuid:b,writeCmdUuid:D,notifyUuid:C}=v;if(!f)throw a.trace("Characteristics not found"),new d.TransportError("service not found","BLEServiceNotFound");let x,S,P;for(const e of f)e.uuid===b?x=e:e.uuid===D?S=e:e.uuid===C&&(P=e);if(!x)throw new d.TransportError("write characteristic not found","BLECharacteristicNotFound");if(!P)throw new d.TransportError("notify characteristic not found","BLECharacteristicNotFound");if(!x.properties.write)throw new d.TransportError("The writable-with-response characteristic is not writable with response","BLECharacteristicInvalid");if(!P.properties.notify)throw new d.TransportError("notify characteristic not notifiable","BLECharacteristicInvalid");if(S&&!S.properties.writeWithoutResponse)throw new d.TransportError("The writable-without-response characteristic is not writable without response","BLECharacteristicInvalid");const $=await n.Fk.getMtu(s.deviceId);a.trace(`device.mtu=${$}`);const j=((e,t,i,r)=>new I.c((c=>(new h.LocalTracer("ble-verbose",r).trace("Start monitoring BLE characteristics",{characteristicUuid:i.uuid}),n.Fk.startNotifications(e,t,i.uuid,(e=>{const t=new Uint8Array(e.buffer),i=k.from(t);c.next(i)})),()=>{n.Fk.stopEnabledNotifications()}))))(u,N,P,r).pipe((0,T.W)((e=>{const t=String(e);return t.includes("notify change failed")?(0,p.of)(new d.PairingFailed(t)):(0,m.$)((()=>e))})),(0,y.M)((e=>{e instanceof d.PairingFailed||(0,h.trace)({type:"ble-frame",message:`<= ${e.toString("hex")}`,context:r})})),(0,E.u)()),W=j.subscribe();l=new R(s,x,S,j,g,{context:r,rxjsScheduler:c}),a.trace("New BleTransport created"),l.onDisconnect=e=>{var t,i;l.isConnected=!1,l.notYetDisconnected=!1,W.unsubscribe(),B(l.id),delete L[l.id],a.trace(`On device disconnected callback: cleared cached transport for ${l.id},\n      emitting Transport event "disconnect. Error: ${e}"`,{reason:e}),l.emit("disconnect",e),null===(t=(i=l).disconnectCallback)||void 0===t||t.call(i)},L[l.id]=l;const z=Date.now();try{await l.inferMTU()}finally{const e=Date.now();M?(e-z<M.pairingThreshold?t=!1:g.id===o.Dp.stax&&(a.trace('Skipping "needsReconnect" strategy for Stax'),t=!1),t&&(a.trace("Device needs reconnection. Triggering a disconnect"),await R.disconnectDevice(l.id,l.onDisconnect),await(_=M.delayAfterFirstPairing,new Promise((e=>setTimeout(e,_)))))):t=!1}var _;return t?(a.trace("Reconnecting"),q(s,!1,i,r)):l}let j,W,z=[];function _(){return!!$}function Y(e){return!!z.find((t=>t.identifier===e.identifier))&&!j}async function H(e){try{if(!Y(e))return;const t=await R.open(e.device);if(!Y(e))return;const i={device:e.device,bleTransport:t};j=i,t.disconnectCallback=()=>{j=void 0,_()&&(V(),Q())},setTimeout((()=>{var e,t;(null===(e=j)||void 0===e?void 0:e.device.deviceId)===i.device.deviceId?(null===(t=W)||void 0===t||t(i),V()):_()&&(j=void 0,V(),Q())}),1e3)}catch(t){setTimeout((()=>{H(e)}),1e4)}}function Q(){$=R.listen({next:e=>{if("add"===e.type&&e.device){if(!e.device.name)return;if(z.find((t=>{var i;return t.device.deviceId===(null===(i=e.device)||void 0===i?void 0:i.deviceId)})))return;const t={identifier:(0,r.A)(),device:e.device};z.push(t),H(t)}},error:()=>{V()},complete:()=>{V()}})}function V(){var e;z=[],null===(e=$)||void 0===e||e.unsubscribe(),$=void 0}const G={isSupported:async function(){if(!c.UMQ)return!1;try{await n.Fk.initialize({androidNeverForLocation:!0}),await n.Fk.requestEnable()}catch(e){}return n.Fk.isEnabled()},connect:function(){return new Promise((e=>{W=e,j?W(j):_()||Q()}))},stop:V}}}]);
//# sourceMappingURL=642.0cbff8d83531f17fc7b4.js.map